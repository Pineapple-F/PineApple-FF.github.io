<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/05/13/%E7%A0%94%E8%AE%A8%E8%AF%BE/"/>
      <url>/2024/05/13/%E7%A0%94%E8%AE%A8%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解和实践“基于规格的层次化设计”"><a href="#如何理解和实践“基于规格的层次化设计”" class="headerlink" title="如何理解和实践“基于规格的层次化设计”"></a>如何理解和实践“基于规格的层次化设计”</h2><p>基于JML规格的java层次化设计，首先是基于规格，其次是层次化设计</p><ol><li><p>基于规格：在第三单元中，我们要按照课程组给出的jml来编写代码。首先第一步是阅读jml，明白要求所在。jml要求做的一定要做，jml不让做的一定不做。</p><p>这里回顾总结一下jml语法，然后说几个易错易忽略的地方</p></li><li><p>之后，我们根据要求进行程序设计，将每个方法按照jml逐个实现。由于jml有很清楚的规范，所以编写代码的难度并不高。但是有些部分不能完全按照jml中的实现方式（比如jml会出现一些嵌套for循环的情况），这时候就需要我们自己使用其他算法，来降低时间复杂度</p><p>这里展示更方法算法及其时间复杂度</p></li><li><p>总论：为了降低时间复杂度，应该避免一切复杂度为O(n^2)及以上的情况，能维护就维护，然后这里展示一下维护和不维护的对比。</p><p>在第三单元，按照jml编写代码确实大大降低了整体思维难度，每条指令相对独立，而且整体架构比较简单，出bug的时候也非常容易确定具体位置。我们只要做的就是优化，维护。工作量和debug难度比第二单元少了很多。</p></li></ol><h2 id="如何基于规格开展自动化测试（包括测试数据构造和测试断言构造）"><a href="#如何基于规格开展自动化测试（包括测试数据构造和测试断言构造）" class="headerlink" title="如何基于规格开展自动化测试（包括测试数据构造和测试断言构造）"></a>如何基于规格开展自动化测试（包括测试数据构造和测试断言构造）</h2><ol><li><p>test：每次中测的test确实令人头大。test的编写思路就是首先构造数据点，然后按照jml逐条验证，这里展示一下测试方案（就是一堆assertEqual).经过两次的经验，我认为test可以从一下两点来增强对一个方法测试强度：</p><ul><li><p>增加数据覆盖程度:设计更全面的数据点，覆盖各个情况</p><p>展示我的数据点</p></li><li><p>在每次操作指令完成后，都测试一下是否满足jml要求</p></li></ul></li><li><p>评测机：</p><ul><li><p>评测机会利用覆盖面较强的数据检测程序的正确性，但是针对于具体一条指令检测它是不是超时还需要手搓数据，展示一下我手搓的数据</p><p>手搓思路：先加很多个人，再加很多关系，针对要测试的指令复杂度O(n)中的n，尽量增大n</p></li></ul></li><li><p>互测阶段：我个人前两次作业的强测和互测都没出现bug，hack策略也是向上面一样分两种：一是检测正确性，二是手捏一个只针对某条指令的数据，测它超不超时</p></li></ol><h2 id="调研分析契约式设计方法的实际应用情况"><a href="#调研分析契约式设计方法的实际应用情况" class="headerlink" title="调研分析契约式设计方法的实际应用情况"></a>调研分析契约式设计方法的实际应用情况</h2><p>尽管契约式设计的理念非常有吸引力，但其在商业应用中并不十分普遍，它基本用于高精尖领域比如：</p><ol><li><strong>安全关键系统</strong>：对于安全性要求高的系统，如航空航天、医疗设备、金融系统等，契约式设计可以用来确保系统的正确性和可靠性。通过定义前置条件、后置条件和类不变式，可以确保系统行为符合预期，并且在异常情况下能够正确处理。</li><li><strong>实时系统</strong>：实时系统对响应时间和性能有较高要求，因此需要确保系统的行为可预测和可控。契约式设计可以帮助开发者定义系统的行为和性能要求，并通过约束条件来确保系统在各种情况下都能够满足这些要求。</li><li><strong>复杂系统</strong>：对于复杂系统，如大型分布式系统、微服务架构等，契约式设计可以帮助管理系统之间的依赖关系和交互。通过定义接口规约和约束条件，可以确保不同组件之间的协作和交互符合预期，从而提高系统的可维护性和可扩展性。</li><li><strong>高质量软件</strong>：契约式设计可以帮助开发团队确保软件的质量和稳定性。通过定义规约和约束条件，可以在开发过程中进行静态检查和验证，及早发现和修复潜在的问题，从而提高软件的健壮性和可靠性。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>oo-Unit3</title>
      <link href="/2024/05/13/oo-Unit3/"/>
      <url>/2024/05/13/oo-Unit3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过了上一单元电梯的折磨，我个人感觉这次的JML相比之下还是比较容易的吧</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="容器的选择"><a href="#容器的选择" class="headerlink" title="容器的选择"></a>容器的选择</h3><p>本次单元作业的绝大多数指令都是通过id来寻找对应的tag，Person还有Meessage。</p><p>以Person为例，如果把所有的Person都放在一个List容器里，那么我们每次查找都需要遍历一遍容器，算法复杂度为O(n)，很容易出现TLE。</p><p>所以我选择了HashMap作为存储容器，将id作为键值，这样可以保证每次查询都能以O(1)的复杂度完成。</p><img src="/image/${fiilename}/image-20240516105328644.png" alt="image-20240516105328644" style="zoom: 50%;" /><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>由于本单元的各个方法之间相对独立，所以我就逐个分析一下我优化的方法。</p><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><p><img src="/image/$%7Bfiilename%7D/image-20240516110252138.png" alt="image-20240516110252138"></p><p>第一次作业中呢，有三个较为复杂的方法：<code>isCircle</code>，<code>queryBlockSum</code>和<code>queryTripleSum</code>。那首先就单纯看JML我们可以看到<code>queryBlockSum</code>是二重for循环，<code>queryTripleSum</code>是三重for循环。这种O(n^2)及以上的时间复杂度肯定是不行的，所以我们可以通过并查集和随时维护来进行降低时复杂度。</p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>首先我的并查集中有三个容器: parent存放每个节点的根节点，rank存放每个节点的秩，graph存放与每个节点直接相连的各节点。然后再通过路径压缩，按秩合并和关系删除来降低这两个方法的时间复杂度。</p><p><img src="/image/$%7Bfiilename%7D/image-20240516105903693.png" alt="image-20240516105903693"></p><p>路径压缩的意思就是我们在找一个元素的根节点的时候，比如这张图我们要找a的根节点，于是a找到b，b找到c，一直找到f，那我们就把这一路上所有节点的根节点都设为f。这样做的目的就是在一个连通分支内所有元素的根节点都是一个元素，这样我们只需要比较两个节点的根节点就可以判断他们是否连通了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> id;</span><br><span class="line">        <span class="keyword">while</span> (root != parent.get(root)) &#123;</span><br><span class="line">            root = parent.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> id;</span><br><span class="line">        <span class="keyword">while</span> (now != root) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fa</span> <span class="operator">=</span> parent.get(now);</span><br><span class="line">            parent.put(now, root);</span><br><span class="line">            now = fa;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是按秩合并，就是说我们要将并查集的两个连通分支连起来的时候，总是将秩较低的树的根指向秩较高的树的根。这样可以一定程度上减短查找路径。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = graph.get(id1);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet2 = graph.get(id2);</span><br><span class="line">        hashSet1.add(id2);</span><br><span class="line">        graph.put(id1, hashSet1);</span><br><span class="line">        hashSet2.add(id1);</span><br><span class="line">        graph.put(id2, hashSet2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">root1</span> <span class="operator">=</span> find(id1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">root2</span> <span class="operator">=</span> find(id2);</span><br><span class="line">        <span class="keyword">if</span> (root1 == root2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blockCnt--;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rank1</span> <span class="operator">=</span> rank.get(root1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rank2</span> <span class="operator">=</span> rank.get(root2);</span><br><span class="line">        <span class="keyword">if</span> (rank1 &lt; rank2) &#123;</span><br><span class="line">            parent.put(root1, root2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank1 &gt; rank2) &#123;</span><br><span class="line">            parent.put(root2, root1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rank.put(root1, rank1 + <span class="number">1</span>);</span><br><span class="line">            parent.put(root2, root1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是关系的删除。比如我们删除AB之间的关系，需要对并查集做一下更新，这时候有两种情况就是删完关系之后AB仍连通或者AB不连通了。那操作方法就是我们先更新一下graph然后对Adfs，把跟A有关系的点的根设为A，秩设为1。这样我们就可以建立一个以A为根节点的联通分支，然后如果这里面有B,那无事发生，我们不需要再操作B了。但如果这里面没有B，那就说明AB不再联通，此时我们就再也B为根节点，重复刚才对A的操作就可以更新完并查集了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = graph.get(id1);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet2 = graph.get(id2);</span><br><span class="line">        hashSet1.remove(id2);</span><br><span class="line">        graph.put(id1, hashSet1);</span><br><span class="line">        hashSet2.remove(id1);</span><br><span class="line">        graph.put(id2, hashSet2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dfs 和id1相连根节点全变成id1</span></span><br><span class="line">        HashSet&lt;Integer&gt; set1 = dfs(id1, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (Integer id : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == id2) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent.put(id, id1);</span><br><span class="line">            rank.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            blockCnt++;</span><br><span class="line">            <span class="comment">//dfs 和id2有关全变成id2</span></span><br><span class="line">            HashSet&lt;Integer&gt; set2 = dfs(id2, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span> (Integer id : set2) &#123;</span><br><span class="line">                parent.put(id, id2);</span><br><span class="line">                rank.put(id, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>queryTripleSum</code>方法，我们在每次增删关系后维护，这样虽然每次维护时的时间复杂度从O(1)变成了O(n)，但是查询时的时间复杂度从O(n^3)变成了O(1)，大大降低了时间复杂度。</p><h4 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h4><p><img src="/image/$%7Bfiilename%7D/image-20240516110235799.png" alt="image-20240516110235799"></p><p>然后第二次作业依然是一些新增了Tag和一些指令，对于复杂度是O(n^2)及以上的一定需要优化。</p><p>这里有一个方法是<code>queryTagValueSum</code>右边是直接按照JML写的方法，他的时间复杂度是O(n^2)，我听说不少同学因为直接就是这么写的，没有维护这个方法然后强测挂了一个点。那左边是每次删改关系时都要维护，乍一看好像是两个都是嵌套for循环，但其实左边这个维护时只是遍历所有的Tag，双重for循环也只是找到所有Tag而已，所以时间复杂度依然是O(n)。</p><p>其他的方法比如<code>queryBestAcquaintance</code>，因为他复杂度是n，所以我没维护他。<code>queryCoupleSum</code>就是每次增删改关系时先调用一下<code>queryBestAcquaintance</code>，然后根据两个人的老couple和新couple通过一些if判断语句来维护<code>coupleSum</code>，可以将复杂度降为O(1)。</p><p>还有这个搜索最短路径就可以直接<code>bfs</code>，广度优先搜索。我是使用双向<code>bfs</code>做了一点优化。</p><h4 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h4><p>然后第三次作业的方法复杂度最多就是O(n)，我个人没有做算法优化。</p><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><h3 id="黑箱测试"><a href="#黑箱测试" class="headerlink" title="黑箱测试"></a>黑箱测试</h3><p>黑箱测试是指测试应用程序的功能而不是其内部的结构和运作，测试者只需要知道什么是系统该做的事情。意思差不多就是使用数据点或者评测机测试程序，例如中测强测就都是黑箱测试。</p><h3 id="白箱测试"><a href="#白箱测试" class="headerlink" title="白箱测试"></a>白箱测试</h3><p>白箱测试又叫结构测试，测试者需要知道程序的结构和处理算法，按照程序内部逻辑设计测试用例，检测主要执行通路是否都能按预定要求正常工作。我认为就是类似于<code>JUnit</code>实现的单元测试。</p><h3 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h3><ul><li><p>单元测试<br>单元测试是指对软件中的最小可测单元进行检查，这里我理解的就是对每个方法进行测试。例如我们在本单元编写的<code>JUnit</code>测试</p></li><li><p>功能测试<br>我理解的功能测试其实就是黑盒测试。我的作业也主要是进行黑盒测试。将数据输入多个程序，比对输出是否一致，进行只关注输入输出是否正确的功能测试。</p></li><li><p>集成测试<br>集成测试是将不同的模块集成为一个整体进行测试。主要测试各模块之间的数据通信。</p></li><li><p>压力测试</p><p>顾名思义，就是对程序提供压力数据，测试程序的性能表现。我在本单元的hw10中进行了压力测试。</p><p>hw10在于同学对拍的时候发现偶尔有些数据我会跑的很慢，经过不断缩小数据范围，排查出基本上是<code>qtvs</code>的问题，然后生成只含<code>ap</code> <code>ar</code>这些初始化指令和<code>qtvs</code>指令的大量数据来进行压力测试，基本确定问题所在。</p></li><li><p>回归测试<br>回归测试是对软件的原来状态重新测试，以确保软件在迭代出新版本之后，仍能符合之前的要求。具体来说，可以拿上次作业的测试程序与测试数据来测这次作业。我没有进行回归测试，感觉没什么必要，上次作业涉及的部分基本上没有功能实现上的改的。</p></li></ul><h3 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h3><p>因为有评测机去检测程序的正确性，所以我们手动构造数据时基本就只需要检测程序的性能即可，也就是单个指令的优化做的到不到位。</p><p>我的构造思路大概是这样：</p><ul><li><p>先加很多个人和关系</p></li><li><p>针对要测试的指令复杂度O(n)中的n，尽量增大n</p></li><li><p>再添加要测试的指令达到我们的目的。</p></li></ul><h2 id="性能与Bug"><a href="#性能与Bug" class="headerlink" title="性能与Bug"></a>性能与Bug</h2><p>在性能方面，我是采取能维护就维护的原则，将时间复杂度较高的方法全都进行优化，以避免在强测中出现TLE。</p><p>很幸运，本单元三次作业我在强测和互测中均未出现bug，其实很大程度上也得益于本单元作业的整体架构比较简单，不会像第二单元出现各种奇奇怪怪的bug。</p><p>在写本单元作业前，就听说要做到规格和实现分离，一开始还并不太懂什么意思。但是完成了本单元作业之后，就可以体会到这句话的意思：规格的目的是限定我们的行为，但不固定我们具体的行为，我们并不需要完全按照JML的朴素算法完成要求，而是可以通过各种算法来做到性能优化。</p><h2 id="关于JUnit"><a href="#关于JUnit" class="headerlink" title="关于JUnit"></a>关于JUnit</h2><p>本次作业的<code>JUint</code>在前两次作业也是卡了我很多次，但其实<code>JUnit</code>的编写也是有一点套路：</p><ul><li>首先构造数据点</li><li>然后在每次操作指令完成后，都测试一下</li><li>每次测试就是按照jml逐条验证</li></ul><p>这样的<code>JUint</code>测试就可以很好地检测该方法是否完全符合JML的要求和限定，也是属于白箱测试的优点。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>总的来说，我感觉在第三单元，按照jml编写代码确实让每个方法都变得很清晰，而且整体架构也比前两个单元简单，都是单个方法的算法优化。而且出bug的时候也非常容易确定具体位置，我们主要做的就是优化，维护，降低时间复杂度。</p><p>同时本单元也让我体会到了各种测试，以前只是听过那么多测试方法，但是在这单元的作业中，我也是利用了各种测试，共同保证了程序的正确性。</p><p>对于JML，我个人觉得其实还挺好玩的，在本届JML中可以调用之前的方法，也降低了阅读JML的难度。有了JML，确实可以规范好每个方法的行为，减少了出现错误的概率，让程序更加可靠。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-lab3</title>
      <link href="/2024/04/22/OS-lab3/"/>
      <url>/2024/04/22/OS-lab3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking  3.1"></a>Thinking  3.1</h3><p><strong>请结合 MOS 中的页目录自映射应用解释代码中<code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code>的含义。</strong></p><p>答：</p><p>PDX(UVPT)是得出UVPT所处的页目录号，即UVPT处于第PDX(UVPT)个页目录项所映射的4MB空间，因此页目录也被第PDX(UVPT)映射，然后将该页目录号所对应的的页目录项映射为页目录的物理基地址，并且加上权限位。</p><p>页目录基地址：</p><p>UVPT+UVPT&gt;&gt;10</p><p>映射到页目录的页目录项的基地址：</p><p>UVPT+UVPT&gt;&gt;10+UVPT&gt;&gt;20</p><p>该页表项处于第几个页目录项：</p><p>(UVPT&gt;&gt;20) &gt;&gt; 2 &#x3D; UVPT&gt;&gt;22 &#x3D; PDX(UVPT)</p><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><p><strong><code>elf_load_seg</code>以函数指针的形式，接受外部自定义的回调函数<code>map_page</code>。 请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</strong> </p><p>答：</p><p>data是传入的进程控制块指针，在load_icode_mapper和load_icode函数中被调用，在load_icode函数中data被赋予进程控制块的指针e</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm,<span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123; </span><br><span class="line">    …… </span><br><span class="line">    panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br><span class="line">    …… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能没有这个参数，因为需要根据这个进程去实现它的内存管理，为这个进程分配相应的物理页。</p><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a><strong>Thinking 3.3</strong></h3><p><strong>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</strong></p><p>答：</p><ol><li><p>首先，函数判断va是否页对齐，如果不对齐，需要将多余的地址记为offset，并且offset所在的剩下的BY2PG的binary数据写入对应页的对应地址；（第一个 map_page）</p></li><li><p>然后，依次将段内的页映射到物理空间；（第二个 map_page）</p></li><li><p>最后，若发现其在内存的大小大于在文件中的大小，则需要把多余的空间用0填充满。（第三个 map_page）</p></li></ol><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a><strong>Thinking 3.4</strong></h3><p><strong>思考上面这一段话，并根据自己在 Lab2 中的理解，回答：你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?</strong></p><p>我认为存储的虚拟地址，因为epc存储的是发生错误时CPU所处的指令地址，那么对于CPU来说，所见的都是虚拟地址，因此env_tf.cp0_epc存储的是虚拟地址。</p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><p><strong>试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用） 涉及的 do_syscall() 函数将在 Lab4 中实现。</strong> </p><p>答：</p><p><code>handle_int</code>在<code>genex.S</code>文件中</p><p><code>handle_mod</code>和<code>handle_tlb</code>，handle_sys都是通过<code>genex.S</code>文件中的宏函数<code>BUILD_HANDLER</code>实现的</p><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><p><strong>阅读 entry.S、genex.S 和 env_asm.S 这几个文件，并尝试说出时钟中断 在哪些时候开启，在哪些时候关闭。</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enable_irq </span><br><span class="line">li t0, (STATUS_CU0 | STATUS_IM4 | STATUS_IEc) //将t0赋为打开时钟中断的值 </span><br><span class="line">mtc0 t0, CP0_STATUS //将t0的值赋给SR寄存器，使之可以相应时钟中断</span><br><span class="line">jr ra //返回 </span><br><span class="line">timer_irq </span><br><span class="line">sw zero, (KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK) //写 KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK 地址响应时钟中断 li a0, 0 </span><br><span class="line">j schedule //走到调度函数，进行进程调度</span><br></pre></td></tr></table></figure><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><p><strong>阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</strong> </p><p>当内核创建新进程时，将其插入调度链表的头部；在其不再就绪（被阻塞）或退出时，将其从调度链表中移除。当时间片使用完了，我们将当前的进程控制块插入到调度链表的尾部。接下来从调度链表的头部取出一个就绪的进程进行切换。</p><h2 id="二、难点分析"><a href="#二、难点分析" class="headerlink" title="二、难点分析"></a>二、难点分析</h2><p>接下来，我们还是从lab3的12个exercise入手，依次分析</p><h3 id="Exercise-3-1-env-init"><a href="#Exercise-3-1-env-init" class="headerlink" title="Exercise 3.1 : env_init()"></a>Exercise 3.1 : env_init()</h3><p>像之前一样，对于进程，我们也是从进程初始化开始。</p><p>说他是初始化函数，但其实他并不是对每个进程内部进行初始化，他的作用有两个：</p><ol><li>初始化env_free_list和env_sched_list这两个链表</li><li>段地址映射</li></ol><p>第一个作用很简单，就是将envs数组中的所有进程倒序存进env_free_list，和页表初始化几乎一致。</p><p>但是第二个作用刚开始看可能会比较令人费解，其实呢，我们可以理解为我们创建了一个模板页目录，将map_segment 函数在该页表中将内核数组 pages 和 envs 映射到了用户空间的 UPAGES 和 UENVS 处。这样的好处就是用户程序也能够通过 <code>UPAGES</code> 和 <code>UENVS</code> 的用户地址空间获取 <code>Page</code> 和 <code>Env</code> 的信息，而不用去访问内核。</p><h3 id="Exercise-3-2-map-segment"><a href="#Exercise-3-2-map-segment" class="headerlink" title="Exercise 3.2 : map_segment()"></a>Exercise 3.2 : map_segment()</h3><p>刚才我们说到env_init()中的最后调用了map_segment()来完成段地址映射，那我们来看看这个函数的作用：将在一级页表基地址 pgdir 对应的两级页表结构中做段地址映射，将虚拟地址段 [va,va+size) 映射到物理地址段 [pa,pa+size)</p><p>在lab2中，我们实现了page_insert()，它的作用就是把一个虚拟地址va映射到一个物理页面上，那现在我们需要将虚拟地址段 [va,va+size) 映射到物理地址段 [pa,pa+size)，也就只需要一页一页的调用page_insert()来映射就好了。</p><h3 id="Exercise-3-3-env-setup-vm"><a href="#Exercise-3-3-env-setup-vm" class="headerlink" title="Exercise 3.3 : env_setup_vm()"></a>Exercise 3.3 : env_setup_vm()</h3><p>在完成最初的初始化后，根据lab2中的套路，接下来我们要开始env_alloc()了，那Exercise 3.3的env_setup_vm()正是在env_alloc()中调用的一个函数，他的作用是是初始化新进程的地址空间。因为每个进程都有独立的地址空间，所以要为新进程初始化页目录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o     4G -----------&gt;  +----------------------------+------------0x100000000</span><br><span class="line">o                      |       ...                  |  kseg2</span><br><span class="line">o      KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span><br><span class="line">o                      |          Devices           |  kseg1</span><br><span class="line">o      KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span><br><span class="line">o                      |      Invalid Memory        |   /|\</span><br><span class="line">o                      +----------------------------+----|-------Physical Memory Max</span><br><span class="line">o                      |       ...                  |  kseg0</span><br><span class="line">o      KSTACKTOP-----&gt; +----------------------------+----|-------0x8040 0000-------end</span><br><span class="line">o                      |       Kernel Stack         |    | KSTKSIZE            /|\</span><br><span class="line">o                      +----------------------------+----|------                |</span><br><span class="line">o                      |       Kernel Text          |    |                    PDMAP</span><br><span class="line">o      KERNBASE -----&gt; +----------------------------+----|-------0x8001 0000    |</span><br><span class="line">o                      |      Exception Entry       |   \|/                    \|/</span><br><span class="line">o      ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span><br><span class="line">o                      |         User VPT           |     PDMAP                /|\</span><br><span class="line">o      UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    |</span><br><span class="line">o                      |           pages            |     PDMAP                 |</span><br><span class="line">o      UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    |</span><br><span class="line">o                      |           envs             |     PDMAP                 |</span><br><span class="line">o  UTOP,UENVS   -----&gt; +----------------------------+------------0x7f40 0000    |</span><br><span class="line">o  UXSTACKTOP -/       |     user exception stack   |     BY2PG                 |</span><br><span class="line">o                      +----------------------------+------------0x7f3f f000    |</span><br><span class="line">o                      |                            |     BY2PG                 |</span><br><span class="line">o      USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    |</span><br><span class="line">o                      |     normal user stack      |     BY2PG                 |</span><br><span class="line">o                      +----------------------------+------------0x7f3f d000    |</span><br><span class="line">a                      |                            |                           |</span><br><span class="line">a                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |</span><br><span class="line">a                      .                            .                           |</span><br><span class="line">a                      .                            .                         kuseg</span><br><span class="line">a                      .                            .                           |</span><br><span class="line">a                      |~~~~~~~~~~~~~~~~~~~~~~~~~~~~|                           |</span><br><span class="line">a                      |                            |                           |</span><br><span class="line">o       UTEXT   -----&gt; +----------------------------+------------0x0040 0000    |</span><br><span class="line">o                      |      reserved for COW      |     BY2PG                 |</span><br><span class="line">o       UCOW    -----&gt; +----------------------------+------------0x003f f000    |</span><br><span class="line">o                      |   reversed for temporary   |     BY2PG                 |</span><br><span class="line">o       UTEMP   -----&gt; +----------------------------+------------0x003f e000    |</span><br><span class="line">o                      |       invalid memory       |                          \|/</span><br><span class="line">a     0 ------------&gt;  +----------------------------+ ----------------------------</span><br><span class="line">o</span><br></pre></td></tr></table></figure><p>而这里我们要暴露是上图 UTOP 往上到 UVPT 之间所有进程共享的只读空间，因为我们刚才map_segment()已经完成base_pgdir到UTOP~UVPT的映射，所以我们只需要把这部分内存对应的内核页表 base_pgdir 拷贝到我们现在的进程页表中即可，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP), </span><br><span class="line"><span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br></pre></td></tr></table></figure><p>这样，我们每个用户程序就都可以不用切换到内核态就可以访问到envs和pages数组的内容了。</p><p>然后从 UVPT 往上到 ULIM 之间才是进程自己的页表。</p><p>在env_setup_vm()最后，我们完成了页表自映射，并设置权限只读，见Thinking 3.1</p><h3 id="Exercise-3-4-env-alloc"><a href="#Exercise-3-4-env-alloc" class="headerlink" title="Exercise 3.4 : env_alloc()"></a>Exercise 3.4 : env_alloc()</h3><p>好的，刚才说env_setup_vm()是env_alloc()的一小步，那我们现在来完成看看这个进程分配函数，他分四步完成：</p><ol><li><p>从env_free_list取出了一个空闲进程控制块（PCB）</p></li><li><p>调用env_setup_vm()初始化进程控制块的用户地址空间。也就是为进程控制块创建对应的二级页表。</p></li><li><p>接下俩继续初始化PCB的一些其他信息，本lab要填写的是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;env_id = mkenvid(e);</span><br><span class="line">try(asid_alloc(&amp;e-&gt;env_asid));</span><br><span class="line">e-&gt;env_parent_id = parent_id;</span><br></pre></td></tr></table></figure></li></ol><p>​除此之外，e-&gt;env_tf.cp0_status要进行对应的中断使能位赋值，e-&gt;env_tf.regs[29]设置栈指针。</p><ol start="4"><li>然后我们已经完成了本函数对这个PCB的初始化操作，接下来就把他从env_free_list中移除即可</li></ol><h3 id="Exercise-3-5-load-icode-mapper"><a href="#Exercise-3-5-load-icode-mapper" class="headerlink" title="Exercise 3.5 : load_icode_mapper()"></a>Exercise 3.5 : load_icode_mapper()</h3><p>接下来，我们要做的事情是把将程序加载到新进程的地址空间中。</p><p>这里有很多层函数调用关系</p><p>首先我们进入load_icode()函数，这个函数遍历ELF文件每个段的段头表，并调用elf_load_seg()将每个段加载新进程的地址空间中，而我们这里的load_icode_mapper()就是elf_load_seg()的一个回调函数，由它完成段中单个页面的加载过程</p><p>所以，这里回调函数load_icode_mapper()的作用是分配所需的物理页面，并在页表中建立映射。若 src 非空，你还需要将该处的 ELF 数据拷贝到物理页面中。</p><p>实现过程也就是：</p><ol><li>分配一个物理页面</li><li>若 src 非空，将该处的 ELF 数据拷贝到申请的物理页面中</li><li>并在该进程的页表中建立新申请的物理页面的映射</li></ol><h3 id="Exercise-3-6-load-icode"><a href="#Exercise-3-6-load-icode" class="headerlink" title="Exercise 3.6 : load_icode()"></a>Exercise 3.6 : load_icode()</h3><p>刚才说了，load_icode()是完成程序加载的主函数（姑且这么叫），它调用了不少函数完成了将整个程序加载到新进程的地址空间中，那么还差最后一步，就是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;env_tf.cp0_epc = ehdr-&gt;e_entry;</span><br></pre></td></tr></table></figure><p>将进程恢复运行时的回到位置e-&gt;env_tf.cp0_epc设置为刚才加载完的程序的入口ehdr-&gt;e_entry</p><h3 id="Exercise-3-7-env-create"><a href="#Exercise-3-7-env-create" class="headerlink" title="Exercise 3.7 : env_create()"></a>Exercise 3.7 : env_create()</h3><p>前面准备了这么多，我们终于可以创建一个进程了，我们会发现这个函数干的事就是把之前说的那些函数合起来，分四步：</p><ol><li>调用env_alloc()申请一个进程</li><li>设置申请到的进程的e-&gt;env_pri（其实就是时间片），并将e-&gt;env_status设置为ENV_RUNNABLE</li><li>调用load_icode加载程序到进程的地址空间</li><li>将申请到的进程加入到env_sched_list的头部</li></ol><h3 id="Exercise-3-8-env-run"><a href="#Exercise-3-8-env-run" class="headerlink" title="Exercise 3.8 : env_run()"></a>Exercise 3.8 : env_run()</h3><p>上一步我们创建的线程是一个静态的线程，接下来我们就要让它跑起来</p><p>他也是分两步：</p><ol><li>将正在执行的进程（如果有）的现场保存到对应的进程控制块中。</li><li>将curenv换成env_run()的参数e（也可能还是原来的进程），然后将当前的页表基地址换成现在进程的页表基地址</li><li>恢复现场，异常返回</li></ol><p>这里的异常返回使用了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span><br></pre></td></tr></table></figure><p>其中是对中断返回的处理，那中断的内容我们在接下来说说</p><h3 id="Exercise-3-9-exc-gen-entry"><a href="#Exercise-3-9-exc-gen-entry" class="headerlink" title="Exercise 3.9 :  exc_gen_entry"></a>Exercise 3.9 :  exc_gen_entry</h3><p>在中断发生后，CPU会先处理中断并跳转到指定位置，然后交给操作系统处理。</p><p>在本实验中，CPU 发生异常（除了用户态地址的 TLB Miss 异常）后，就会自动跳转到地址 0x80000180 处；发生用户态地址的 TLB Miss 异常时，会自动跳转到地址 0x80000000 处。</p><p>这里我们先写一个位于地址 0x80000180 处的异常分发代码exc_gen_entry，他的作用是：</p><ol><li>使用 SAVE_ALL 宏将保存上下文，关闭中断且允许嵌套异常。</li><li>Cause 寄存器的内容拷贝到 t0 寄存器中并取得 Cause 寄存器中的 2~6 位，也就是对应的异常码</li><li>得到的异常码作为索引在 exception_handlers 数组中找到对应的中断处理函数</li><li>跳转到对应的中断处理函数中，响应异常</li></ol><h3 id="Exercise-3-10-异常处理程序地址"><a href="#Exercise-3-10-异常处理程序地址" class="headerlink" title="Exercise 3.10 : 异常处理程序地址"></a>Exercise 3.10 : 异常处理程序地址</h3><p>刚才说了，我们的异常处理程序位于0x80000000和0x80000180，于是我们需要把这两个异常处理程序放到这个位置即可</p><h3 id="Exercise-3-11-RESET-KCLOCK"><a href="#Exercise-3-11-RESET-KCLOCK" class="headerlink" title="Exercise 3.11: RESET_KCLOCK"></a>Exercise 3.11: RESET_KCLOCK</h3><p>因为我们每次定时器的count和compare相等之后都会引发一次时钟中断，进行是否切换进程的判断，所以每次时钟中断后，我们需要将定时器复位，即初始化。</p><p>那我们这里初始化定时器用到的RESET_KCLOCK宏，就干了两件事：</p><ol><li>将Count寄存器清零</li><li>将Compare寄存器设置为我们期望的时间间隔（为一个定值）</li></ol><h3 id="Exercise-3-12-schedule"><a href="#Exercise-3-12-schedule" class="headerlink" title="Exercise 3.12 : schedule()"></a>Exercise 3.12 : schedule()</h3><p>好了，干了这么多，我们终于到了本实验的最后一步了：调度进程，让进程有序跑起来</p><p>那么我们的进程调度程序就是首先判断是否切换进程，之后再运行进程</p><p>那我们稍微详细说一下切换进程这里，首先切换进程有四个条件：</p><ol><li>尚未调度过任何进程（curenv &#x3D;&#x3D; NULL）；</li><li>当前进程已经用完了时间片 ( count &lt;&#x3D; 0)；</li><li>当前进程不再就绪（e-&gt;env_status !&#x3D; ENV_RUNNABLE）；</li><li>yield 参数指定必须发生切换 ( yield &#x3D;&#x3D; 1)。</li></ol><p>如果需要进程切换，首先将当前存在进程，就把他从env_sched_list中删去，但如果他仍然是就绪态，就把他再加回调度队列的末尾。</p><p>然后再从调度队列中取出头部的进程，从而完成进程切换。</p><h2 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h2><p>lab3主要是对进程的创建和运行，对中断的处理。</p><p>有了lab2的经验之后，理解lab3也相对没有那么困难。主要就是捋清楚各个函数的调用关系和各自的作用以及实现逻辑，就可以比较好的弄明白从零开始的进程调度运行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>oo-Unit2</title>
      <link href="/2024/04/20/oo-Unit2/"/>
      <url>/2024/04/20/oo-Unit2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又是三周的oo，终于结束了电梯的单元。</p><p>第二单元的编程难度和debug难度对我个人而言都远高于第一单元，真的是好费劲，不过不管咋样，也还算是顺利结束了这一单元的学习吧。</p><p>下面，我将分别对这三次作业进行分析。</p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​我们要模拟的电梯系统是一个类似北京航空航天大学新主楼的电梯系统，楼座内有<strong>多部电梯</strong>，电梯可以在楼座内1-11层之间运行。系统从标准输入中读入乘客请求信息(起点层，终点楼层)，<strong>请求调度器</strong>会根据此时电梯运行情况(电梯所在楼层，运行方向等)将乘客请求合理<strong>分配给某部电梯</strong>，然后被分配请求的电梯会经过<strong>上下行，开关门，乘客进入&#x2F;离开电梯</strong>等动作将乘客从起点层运送到终点层。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>第一次作业还算比较容易，只需要根据生产者-消费者模型，构建输入池，请求池，调度线程以及电梯线程，并编写策略类实现电梯运行策略即可。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p>在整体构建上，我是参考上机实验中的代码框架，进行对应的修改。</p></li><li><p>在策略选择上，我根据往年学长经验选择了LOOK策略，在性能上强于ALS算法。</p></li><li><p>在调度上，由于第一次有具体电梯的编号，所以只需根据这些编号将总请求池的请求分到对应六个电梯的分请求池中即可。</p></li><li><p>由于第一次作业对于锁的认识还不是很深刻，所以我只是在需要读写共享对象时的方法外面加锁，并没有针对具体对象加锁。</p></li></ol><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/image/$%7Bfiilename%7D/image-20240420161527846.png" alt="image-20240420161527846"></p><h3 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>本次作业强测没有出现bug，但互测中出现了bug。</p><p>bug出现在策略类，由于我是在开门的时候判断电梯是否需要转向，但是忽略了一种情况。就是当电梯开门时判断不需要转向，但是在开门之后本层出现一个需要电梯转向的请求，这时候就会发生电梯飞天遁地的情况。</p><p>改正方法也很简单，只需要在电梯关门时判断是否转向即可。</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="新增需求"><a href="#新增需求" class="headerlink" title="新增需求"></a>新增需求</h3><ol><li>请求不再有电梯编号，需要自己设计调度方法</li><li>新增<code>reset</code>重置请求</li></ol><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>整体架构和第一次作业一样，需要在调度器里增加调度方法，同时增加对<code>reset</code>请求的处理。</p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li>调度方法：我并没有采取很多同学使用的影子电梯的策略（担心写出bug），于是自己写了一个调度方法，实现大概如下：<ul><li>首先判断当前是否有可以分配的电梯（如果一个电梯在重置或者他的请求队列大于电梯容量，那么我就判断这个电梯当前是不能分配的），如果没有可以分配的电梯，我们调度器线程wait等待唤醒。</li><li>有分配的电梯后，优先判断可以顺路捎带的电梯。</li><li>没有顺路捎带的电梯，那么我就看看当前的电梯现有的请求是否可以一趟跑完（就是不转向），如果可以那我就把请求分给离他最近的电梯。</li><li>如果以上条件都不满足，那我就把请求分给当前请求最少的电梯。</li></ul></li><li>reset实现：首先在输入类判断是正常电梯请求还是重置请求，如果是重置请求就调用<code>schdule</code>中分配重置请求的方法，并由该方法将对应电梯的<code>needReset</code>标记置1，同时电梯中run方法的最开始判断<code>needReset</code>是否为1，若为1则进行重置。当电梯发生重置时，我就开门把当前电梯中的人全放出来，如果放出来的人还没有到达目标楼层，那我就把他和该电梯请求表里的请求共同打回总请求池重新分配，并修改请求发出楼层为当前楼层。</li><li>对于锁的设计，本次作业一开始我依然像上次一样只对方法加锁，但很快发现了这样无法处理所有的并发情况以及会出现非常多的死锁现象，于是我将所有的锁改成对单个对象加锁。</li></ol><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/image/$%7Bfiilename%7D/image-20240420161705698.png" alt="image-20240420161705698"></p><h3 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>本次作业强测大失败，由于赶上清明假期，我没有很好的检查死锁的情况，导致在强测中出现了很多RTLE的情况。</p><p>于是在Bug修复中我使用了printf和调试暂停的方法找到发生死锁的位置，同时我尽量避免嵌套锁的情况，对每次加锁的位置进行判断，全面修改。</p><p>当然这个过程真的痛苦，一开始我为了避免死锁删除了大量的锁，但又发现出现了并发问题，只好再去添加锁，反反复复改了好多遍，最后才顺利全部修复。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="新增需求-1"><a href="#新增需求-1" class="headerlink" title="新增需求"></a>新增需求</h3><ol><li>新增双轿厢电梯重置请求和双轿厢电梯</li></ol><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><ol><li><p>对于自定义函数的改变很简单，就是在替换的时候再调用一下就好</p><p>**导因子我是通过化简后对需要求导的多项式的每个单项式分别进行求导处理，因为单项式有通项形式，所以实现较为容易</p></li></ol><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li>对于双轿厢电梯的实现：我是新建了双轿厢电梯类，在这个类里有两个电梯线程，同时将这两个电梯都放在schdule类中总电梯池里来分配请求。对于每个双轿厢电梯，我共用一个锁来避免上下两个电梯相撞。</li><li>对于双轿厢重置，我依然是和上次类似，发生重置就把当前电梯中的人全放出来，和请求表里的请求共同打回总请求池重新分配</li><li>由于本周的一半时间都在de上一周的Bug，所以对于调度方法也没有再优化，仍然是采用上一周的调度方法，这也导致了本次作业的性能相对拉胯。</li></ol><h3 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/image/$%7Bfiilename%7D/image-20240420161934695.png" alt="image-20240420161934695"></p><h3 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>本次作业依然出现了一个死锁bug（评测机测了200条数据也没发现我就以为没问题了）</p><p>debug方式依然是和上次类似</p><p>对于房内其他同学的hack依然是和上次一样，在49.9秒加入六个电梯的重置并放入一堆请求来卡120秒的时间。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>​这周作业真的很难，尤其是debug，对于死锁这种复现不了的Bug真的让我de起来毫无头绪，只能结合printf和观察代码来改正。同时由于前两周对于锁的理解没有那么充分，也导致出现了很多bug。</p><p>​但是当第二单元真的结束的时候，也会觉得这三周过得好快。我也在这三周学到了对于线程安全和并发性的处理办法，同时也让我的debug能力进一步提升。同时阅读讨论区中别人的博客，也会让我恍然大悟收获满满，希望再接下来的两个单元里我可以继续探索，继续精进我的设计，一点点进步</p><p>这就是我的第二单元总结了，oo第二单元完结，撒花！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-lab2</title>
      <link href="/2024/04/08/OS-lab2/"/>
      <url>/2024/04/08/OS-lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><p>请根据上述说明，回答问题：</p><ul><li><p>在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？</p></li><li><p>MIPS 汇编程序中 <code>lw</code> 和 <code>sw</code> 指令使用的地址被视为虚拟地址，还是物理地址？</p></li></ul><p>答：</p><ul><li>虚拟地址。自身所写的程序的指针储存地址为映射到进程地址空间的偏移地址，不同进程地址空间是相互隔离的，不同进程两个值相同的指针对应的真实内存是不同的</li><li>虚拟地址。其地址为32位而物理地址为64位</li></ul><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><p>请思考下述两个问题：</p><ul><li>从可重用性的角度，阐述用宏来实现链表的好处。</li><li>查看实验环境中的 <code>/usr/include/sys/queue.h</code>，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul><p>答：</p><ul><li><ol><li>简化代码量</li><li>复杂宏大量调用简单宏可重用性强，可读性强，易于维护</li></ol></li><li><p>单向链表</p><p>对于单纯的插入和删除操作只有O(1)的时间复杂度，但是对于任意第 i 个元素的插入和删除操作来说，则需要从头遍历一遍故而时间复杂度会上升到O(n);</p></li><li><p>双向链表</p><p>对于任意第 i 个元素的插入和删除操作时间复杂度都只有O(1)；</p></li><li><p>循环链表</p><ul><li><p>单向循环链表</p><p>和单向链表一样，对于任意第 i 个元素的插入和删除操作来说，时间复杂度会为O(n);</p></li><li><p>双向循环链表</p><p>和双向链表一样，对于任意第 i 个元素的插入和删除操作来说，时间复杂度会为O(1)。</p></li></ul></li></ul><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><p>请阅读 include&#x2F;queue.h 以及 include&#x2F;pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</p><img src="/image/${fiilename}/image-20240408192944438.png" alt="image-20240408192944438" style="zoom: 67%;" /><img src="/image/${fiilename}/image-20240408193001039.png" alt="image-20240408193001039" style="zoom:67%;" /><img src="/image/${fiilename}/image-20240408193016676.png" alt="image-20240408193016676" style="zoom:67%;" /><p>答：</p><p>首先我们可在<code>include/pmap.h</code>中观察到Page(与真实物理页面相区别，而Page管理一个页面)：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    Page_LIST_entry_t pp_link;  <span class="comment">/* free list link */</span></span><br><span class="line">    u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>又知道<code>Page_LIST_entry_t</code>在宏定义<code>typedef LIST_ENTRY(Page) Page_LIST_entry_t;</code>中声明，查看<code>LIST_ENTRY</code>在<code>queue.h</code>中声明如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type)                                                    \</span></span><br><span class="line"><span class="meta">        struct &#123;                                                                \</span></span><br><span class="line"><span class="meta">                struct type *le_next;   <span class="comment">/* next element */</span>                      \</span></span><br><span class="line"><span class="meta">                struct type **le_prev;  <span class="comment">/* address of previous next element */</span>  \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br></pre></td></tr></table></figure><p>现在可以确定Page的结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>                                                               </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">le_next</span>;</span> </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">    u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>pmap.h</code>中声明的<code>IST_HEAD(Page_list, Page)</code>完成了<code>Page_list</code>的构建如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">lh_first</span>;</span>                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知这个lh_first相当于链表头head，综上Page_list的结构如<strong>C</strong>选项所示。</p><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><p>请思考下面两个问题：</p><ul><li>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID 的必要性。</li><li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳 不同的地址空间的最大数量。</li></ul><p>答：</p><p>ASID的必要性：</p><ul><li>为了提高TLB的性能，将TLB分成Global和process-specific。global 是指常驻在TLB中不会被刷出的，例如内核空间的翻译，process-specific 是指每个进程独有的地址空间，当发生进程切换的时候，这部分TLB可以被刷出，为了支持process-specific的tlb，arm提出了ASID（Adress Space ID）的硬件解决方案，这样TLB就可以识别出这个 TLB 页表项是属于哪一个进程的，这样就不用每次切换进程都要 flush 所有 TLB。</li><li>在 MIPS 中，每一个TLB表项会有一个ASID，标识这个表项是属于哪一个进程的。例如有多个进程都需要使用这个虚拟地址，但若该虚拟地址对应的数据不是共享的，此时该表项不是global项且ASID与CP0_EntryHi的ASID也不一样，表明它们指向的是不同物理地址，需要使此次访问缺失，以保护相应的地址空间。</li></ul><p>可容纳不同地址空间的最大数量：<strong>64个</strong>，参考原文如下：</p><blockquote><p>Instead, the OS assigns a 6-bit unique code to each task’s distinct address space. Since the ASID is only 6 bits long, OS software does have to lend a hand if there are ever more than <strong>64 address spaces</strong> in concurrent use; but it probably won’t happen too often.</p></blockquote><h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><p>请回答下述三个问题：</p><ul><li><code>tlb_invalidate</code> 和 <code>tlb_out</code> 的调用关系？</li><li>请用一句话概括 <code>tlb_invalidate</code> 的作用。</li><li>逐行解释 <code>tlb_out</code> 中的汇编代码。</li></ul><p>答:</p><ul><li><p><code>tlb_invalidate</code>函数内部调用<code>tlb_out</code>函数。</p></li><li><p><code>tlb_invalidate</code>函数就是用<code>tlb_out()</code>把虚拟地址<code>va</code>对应的<code>tlb</code>页表项清空。</p></li><li><p><code>tlb_out</code>该函数根据传入的参数（TLB 的 Key）找到对应的 TLB 表项，并将其清空</p><p>在解释<code>tlb_out</code> 中的汇编代码之前，我们先了解一下有关TLB的相关命令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tlbr：以 Index 寄存器中的值为索引,读出 TLB 中对应的表项到 EntryHi 与 EntryLo。</span><br><span class="line"></span><br><span class="line">tlbwi：以 Index 寄存器中的值为索引,将此时 EntryHi 与 EntryLo 的值写到索引指定的 TLB 表项中。</span><br><span class="line"></span><br><span class="line">tlbwr：将 EntryHi 与 EntryLo 的数据随机写到一个 TLB 表项中（此处使用 Random 寄存器来“随机”指定表项，Random 寄存器本质上是一个不停运行的循环计数器）。</span><br><span class="line"></span><br><span class="line">tlbp：根据 EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器（若未找到匹配项，则 Index 最高位被置 1）。</span><br></pre></td></tr></table></figure><p>​现在我们仔细研究一下tlb_out函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;asm/regdef.h&gt;</span><br><span class="line">#include &lt;asm/cp0regdef.h&gt;</span><br><span class="line">#include &lt;asm/asm.h&gt;</span><br><span class="line">LEAF(tlb_out)</span><br><span class="line">    nop</span><br><span class="line">    //首先将CP0_ENTRYHI中原有的值写入k1寄存器</span><br><span class="line">    mfc0    k1,CP0_ENTRYHI</span><br><span class="line">    //将传入的参数（待清空表项的key）写到CP0_ENTRYHI中</span><br><span class="line">    mtc0    a0,CP0_ENTRYHI</span><br><span class="line">    nop</span><br><span class="line">    //根据 EntryHi 中的 Key，查找 TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器，（若未找到匹配项，则 Index 最高位被置 1）。</span><br><span class="line">    tlbp</span><br><span class="line">    //防止冲突</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    //取出CP0_INDEX的值</span><br><span class="line">    mfc0    k0,CP0_INDEX</span><br><span class="line">    //如果是Index 最高位被置 1，表明没找到，跳到 NOFOUND 标签处，(因为此时相当于已经完成了清空工作)</span><br><span class="line">    //如果找到了，Index 最高位为0，继续执行</span><br><span class="line">    bltz    k0,NOFOUND</span><br><span class="line">    nop</span><br><span class="line">    //为清空做准备，CP0_ENTRYHI，CP0_ENTRYLO全部填入0</span><br><span class="line">    mtc0    zero,CP0_ENTRYHI</span><br><span class="line">    mtc0    zero,CP0_ENTRYLO</span><br><span class="line">    nop</span><br><span class="line">    //根据找到的Index将此时 EntryHi 与 EntryLo 的值写到索引指定的 TLB 表项中，即完成清空</span><br><span class="line">    tlbwi</span><br><span class="line">NOFOUND:</span><br><span class="line"> //复原现场（将原来的key写会CP0_ENTRYHI）</span><br><span class="line">    mtc0    k1,CP0_ENTRYHI</span><br><span class="line">    //跳回被调用的地方</span><br><span class="line">    j   ra</span><br><span class="line">    nop</span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><p>从下述三个问题中任选其一回答：</p><ul><li>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上 的区别。</li><li>简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上 的区别。</li><li>简单了解并叙述 LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存 管理上的区别。</li></ul><p>答：</p><ul><li><p>X86 体系结构中的内存管理机制</p><ul><li>通过分段将逻辑地址转换为线性地址，通过分页将线性地址转换为物理地址。</li><li>逻辑地址由两部分构成，一部分是段选择器，一部分是偏移。</li><li>段选择符存放在段寄存器中，如CS（存放代码段选择符）、SS（存放堆栈段选择符）、DS（存放数据段选择符）和ES、FS、GS（一般也用来存放数据段选择符）等；</li><li>偏移与对应段描述符中的基地址相加就是线性地址。</li><li>操作系统创建全局描述符表和提供逻辑地址，之后的分段操作x86的CPU会自动完成，并找到对应的线性地址。</li><li>从线性地址到物理地址的转换是CPU自动完成的，转化时使用的Page Directory和Page Table等需要操作系统提供。</li></ul></li><li><p>X86 和 MIPS 在内存管理上的区别</p><ul><li>TLB不命中：<ul><li>MIPS触发TLB缺失和充填，然后CPU重新访问TLB</li><li>x86硬件MMU索引获得页框号，直接输出物理地址，MMU充填TLB加快下次访问速度</li></ul></li><li>分页方式不同：<ul><li>一种MIPS系统内部只有一种分页方式</li><li>x86的CPU支持三种分页模式</li></ul></li><li>逻辑地址不同<ul><li>MIPS地址空间32位</li><li>x86支持64位逻辑地址，同时提供转换为32位定址选项</li></ul></li><li>段页式的不同：<ul><li>MIPS同时包含了段和段页式两种地址使用方式</li><li>在x86架构的保护模式下的内存管理中，分段是强制的，并不能关闭，而分页是可选的；</li></ul></li></ul></li></ul><h2 id="二、实验难点"><a href="#二、实验难点" class="headerlink" title="二、实验难点"></a>二、实验难点</h2><p>lab2比前两次lab的难度都提高了很多，从理解和补全代码时都遇到了不小的困难，下面依然按照八个Exercise的顺序逐个分析难点</p><h3 id="Exercise-2-1-mips-detect-memory"><a href="#Exercise-2-1-mips-detect-memory" class="headerlink" title="Exercise 2.1 mips_detect_memory ()"></a>Exercise 2.1 mips_detect_memory ()</h3><p><code>mips_detect_memory()</code>函数用于探测硬件可用内存。本函数其实很简单，首先传进来的参数代表总物理内存字节数，只需要除以每个页面的大小就可以得到总物理页数<code>npage</code>，每个物理页面的大小<code>PAGE_SIZE</code>我们可以再<code>mmu.h</code>中找到。</p><h3 id="Exercise-2-2-LIST-INSERT-AFTER"><a href="#Exercise-2-2-LIST-INSERT-AFTER" class="headerlink" title="Exercise 2.2 LIST_INSERT_AFTER"></a>Exercise 2.2 LIST_INSERT_AFTER</h3><p>在2.2之前，介绍了一些对链表操作的宏，包括创建，插入，删除等操作。在这里，我们要补全LIST_INSERT_AFTER，它的作用是将 elm 插到已有元素 listelm 之后。</p><p>首先，我们先了解一下这个链表的类型，如下：</p><p><img src="/image/$%7Bfiilename%7D/image-20240408200826429.png" alt="image-20240408200826429"></p><p>链表包括指向下一个元素的指针 le_next，以及指向前一个元素链表 项 le_next 的指针 le_prev。le_prev 是一个指针的指针，它的作用是当删除一个元素 时，更改前一个元素链表项的 le_next。</p><p>之后的补全代码部分其实就是大一数据结构学习的链表内容，将需要改动的三个元素的le_next和le_prev进行相应修改即可</p><p>注意的是由于是<code>#define</code>块，除了最后一行外每一行的后面都需要加上<code>/</code></p><h3 id="Exercise-2-3-page-init"><a href="#Exercise-2-3-page-init" class="headerlink" title="Exercise 2.3  page_init"></a>Exercise 2.3  page_init</h3><p>该函数的作用是来初始化物理页面管理，执行一下操作：</p><ol><li>使用链表初始化宏 LIST_INIT。</li><li>将 freemem 按照 PAGE_SIZE 进行对齐（使用 ROUND 宏为 freemem 赋值）。</li><li>将 freemem 以下页面对应的页控制块中的 pp_ref 标为 1。</li><li>将其它页面对应的页控制块中的 pp_ref 标为 0 并使用 LIST_INSERT_HEAD 将其插入空闲链表。</li></ol><p>该部分的代码填写只需按照操作要求一步步补全，从而实现了将freemem前地址( KSEG0 到 freemem )对应所有的页的pp_ref 标为 1，freemem之后地址的pp_ref 标为 0，同时插入空闲链表，便于后续取出空闲页。</p><h3 id="Exercise-2-4-page-alloc"><a href="#Exercise-2-4-page-alloc" class="headerlink" title="Exercise 2.4 page_alloc"></a>Exercise 2.4 page_alloc</h3><p>该函数的作用就是从空闲页链表中取出一页交给传进的参数</p><p>具体操作就是：</p><ol><li>如果空闲页表没有空闲页，就返回异常返回值<code>-E_NO_MEM</code></li><li>有空闲页就取出一页，清空该页后赋给*new，同时将该页在空闲链表中删去</li></ol><h3 id="Exercise-2-5-page-free"><a href="#Exercise-2-5-page-free" class="headerlink" title="Exercise 2.5 page_free"></a>Exercise 2.5 page_free</h3><p>非常简单的一个函数，就是将要free页的pp_ref 标为 0，再插入到空闲链表中</p><h3 id="Exercise-2-6-pgdir-walk"><a href="#Exercise-2-6-pgdir-walk" class="headerlink" title="Exercise 2.6 pgdir_walk"></a>Exercise 2.6 pgdir_walk</h3><p>这个Exercise用于虚拟内存管理，首先我们先来了解一下位于 kuseg 的虚拟地址的两级页表结构如下：（一级页表指代 Page Directory，二级页表指代 Page Table)</p><p><img src="/image/$%7Bfiilename%7D/image-20240408203430180.png" alt="image-20240408203430180"></p><p>那么pgdir_walk函数的作用是将一级页表基地址 pgdir 对应的两级页表结构中 va 虚拟地址所在的二级页表项的指针存储在 ppte 指向的空间上。如果 create 不为 0 且对应的二级页表不存在，则会使用 page_alloc 函数分配一 页物理内存用于存放二级页表，如果分配失败则返回错误码，具体流程如下图：</p><p><img src="/image/$%7Bfiilename%7D/image-20240408210321637.png" alt="image-20240408210321637"></p><p>我们先用一级页表基地址加上偏移量，得到指向一级页表项的指针，取值得到该页表项。如果该页表项无效（存在对应的二级页表），那么如果create为1就调用page_alloc给他分配一页，如果为0就给*ppte赋值NULL。</p><p>如果存在对应的二级页表，那么就将页表项转换为虚拟地址返回，具体转化过程为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*ppte = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp) + PTX(va) * <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>其中<code>*pgdir_entryp</code>即为对应页表项</p><h3 id="Exercise-2-7-page-insert"><a href="#Exercise-2-7-page-insert" class="headerlink" title="Exercise 2.7 page_insert"></a>Exercise 2.7 page_insert</h3><p>该函数的作用是将一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 映射到页控制块 pp 对应的 物理页面，并将页表项权限为设置为 perm，如上图黄色部分所示。</p><p>简单来说就是进行地址的映射，分两种情况，一种是二级页表对应的页和pp相同，一种是不同。</p><p>相同的情况比较简单，就更新一下映射的权限位同时删除TLB中缓存的页表项</p><p>如果不同，就需要先移除之前的映射，然后再分配新的一页映射到pp上，同时删除TLB中缓存的页表项，并接上数据perm和权限位</p><h3 id="Exercise-2-8-tlb-out"><a href="#Exercise-2-8-tlb-out" class="headerlink" title="Exercise 2.8 tlb_out"></a>Exercise 2.8 tlb_out</h3><p>接下来我们来进行对TLB的相应操作，首先我们先来了解一下TLB的结构：</p><p><img src="/image/$%7Bfiilename%7D/image-20240408214402702.png" alt="image-20240408214402702"></p><p>正如指导书中所说：</p><blockquote><p>TLB 事实上构建了一个映射 &lt; VPN, ASID &gt; —TLB →&lt; PFN, N, D, V, G &gt;。</p></blockquote><p>其中<code>ASID</code>表示一虚拟地址在不同的地址空间中通常映射到不同的物理地址。</p><p>对TLB操作时我们有四个可以使用的指令：</p><ul><li>tlbr：以 Index 寄存器中的值为索引，读出 TLB 中对应的表项到 EntryHi 与 EntryLo0、 EntryLo1。</li><li>tlbwi：以 Index 寄存器中的值为索引，将此时 EntryHi 与 EntryLo0、EntryLo1 的值写 到索引指定的 TLB 表项中。</li><li>tlbwr：将 EntryHi 与 EntryLo0、EntryLo1 的数据随机写到一个 TLB 表项中（此处使 用 Random 寄存器来“随机”指定表项，Random 寄存器本质上是一个不停运行的循环计数 器）。</li><li>tlbp：根据 EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项，并将 表项的索引存入 Index 寄存器（若未找到匹配项，则 Index 最高位被置 1）。</li></ul><p>后续我们补全代码时会频繁用到这四个指令。</p><p>首先我们先来补全刚才使用过的tlb_invalidate 函数中调用的tlb_out 函数，按照题目要求插入tlbp和tlbwi即可</p><h3 id="Exercise-2-9-do-tlb-refill"><a href="#Exercise-2-9-do-tlb-refill" class="headerlink" title="Exercise 2.9  _do_tlb_refill"></a>Exercise 2.9  _do_tlb_refill</h3><p>然后我们进行TLB的重填，操作为：</p><ul><li>尝试在循环中调用’page_lookup’以查找虚拟地址 va  在当前进程页表中对应的页表项’ppte’ </li><li>如果’page_lookup’返回’NULL’，表明’*ppte’找不到用’passive_alloc’ 9 为 va 所在的虚拟页面分配物理页面，直至’page_lookup’返回不为’NULL’则退出循环。</li></ul><h3 id="Exercise-2-10-do-tlb-refill"><a href="#Exercise-2-10-do-tlb-refill" class="headerlink" title="Exercise 2.10  do_tlb_refill"></a>Exercise 2.10  do_tlb_refill</h3><p>很简单，只需要使用tlbwr将CP0.EntryHi&#x2F;Lo 随机写入到TLB中即可。</p><h3 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h3><p>本次实验难度较大，首先要理解虚拟地址，物理地址和页表项之间的关系，然后还要清楚诸多函数之间的调用关系并理解每个函数的实现逻辑和作用，确实是任务量不小。</p><p>同时在后面对TLB的操作我还是不是很透彻，日后也还要加深理解，继续深入学习。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-lab1</title>
      <link href="/2024/03/24/OS-lab1/"/>
      <url>/2024/03/24/OS-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><p>请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生 <code>x86</code> 工具链（<code>gcc</code>、<code>ld</code>、<code>readelf</code>、<code>objdump</code> 等）和 <code>MIPS</code> 交叉编译工具链（带有<code>mips-linux-gnu</code>前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 <code>objdump</code> 传入的参数的含义。</p><p>答：</p><p>通过阅读附录<code>A.3</code>，我们可以看到一个简单的<code>printf(&quot;Hello World!&quot;)</code>是怎么一步步预处理，编译，链接并最终变成可执行文件的。因为我们想找到<code>printf</code>到底是在哪里被插入到程序中的，所以我们每次只用<code>gcc</code>执行一次操作，同时使用<code>objump</code>进行反汇编。通过找到汇编语言中<code>callq</code>位置并观察其调用函数的地址来判断该阶段<code>printf</code>是否插入程序中。</p><p>为了使机器码转换回汇编代码，我们使用<code>objdump -参数 要反汇编的目标文件名 &gt; 导出文本文件名</code>命令进行反汇编，那我们先来介绍一下<code>objump</code>相关参数的含义：</p><ul><li><p><code>-S</code> ：用于在反汇编的输出中插入源代码。</p></li><li><p><code>-D</code> ：用于在每条指令前面添加对应的机器码。通常 <code>-D</code> 参数会结合 <code>-S</code> 参数一起使用，以便在反汇编内容中同时显示源代码，机器码和汇编语言。</p></li></ul><p>通过进行和附录相同的操作，可以看出在编译阶段，调用<code>printf</code>函数的地址还是0，而在链接之后，地址变化，所以，<code>printf</code>实际上是在链接时插入到程序中。</p><p>所以，对于拥有多个 c 文件的工程来说，编译器会首先将所有的 c 文件以文件为单位，编译成.o 文件。最后再将所有的.o 文件以及函数库链接在一起，形成最终的可执行文件，整个过程如下图所示：</p><img src="/image/${fiilename}/image-20240324173448949.png" alt="image-20240324173448949" style="zoom: 60%;" /><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><p>思考下述问题： </p><ul><li>尝试使用我们编写的 <code>readelf</code> 程序，解析之前在 <code>target</code> 目录下生成的内核 <code>ELF</code> 文件。</li><li>也许你会发现我们编写的 <code>readelf</code> 程序是不能解析 <code>readelf</code> 文件本身的，而我们刚才介绍的系统工具 <code>readelf</code> 则可以解析，这是为什么呢？（提示：尝试使用 <code>readelf -h</code>，并阅读 <code>tools/readelf</code> 目录下的 <code>Makefile</code>，观察 <code>readelf</code> 与 <code>hello</code> 的不同）</li></ul><p>答：通过执行命令<code>./tools/readelf/readelf ./target/mos</code>，我们可以解析mos文件如下图：</p><img src="/image/${fiilename}/image-20240324180945778.png" alt="image-20240324180945778" style="zoom: 60%;" /><p>​同时<code>readelf</code> 是一个用于查看 ELF 文件信息的工具，但它本身也是一个 ELF 格式的可执行文件。通常情况下，我们自己编写的 <code>readelf</code> 程序是不能解析自身的，这是因为在编写 <code>readelf</code> 程序时，我们使用的是特定的编译器和链接器工具链，生成的可执行文件可能包含一些特定的调试信息或符号表等，这些信息可能超出了我们编写的 <code>readelf</code> 程序所能解析的范围。</p><p>​而系统提供的 <code>readelf</code> 工具则可以解析自身，这是因为系统提供的 <code>readelf</code> 可执行文件是经过专门的编译、链接和调试处理的，其中包含了更多的调试信息和符号表等，使得它能够解析自身的 ELF 头部以及其他信息。</p><p>​通过阅读 <code>tools/readelf</code> 目录下的 <code>Makefile</code>，我发现，target <code>hello</code>下有<code>-static</code>，而<code>readelf</code>没有。</p><img src="/image/${fiilename}/image-20240324181111480.png" alt="image-20240324181111480" style="zoom:50%;" /><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。） </p><p>答：<code>MIPS</code> 系统加电起动后， <code>MIPS</code> 处理器默认的程序入口是 <code>0xBFC00000</code> ，此地址在无缓存的 <code>KSEG1</code> 的地址区域内，对应的物理地址是 <code>0x1FC00000</code> ，即 <code>CPU</code> 从 <code>0x1FC00000</code> 开始取第一条指令，这个地址在硬件上已经确定为 <code>FLASH</code> 的位置，然后 <code>Bootloader</code> 执行功能，加载内核到内存。关于内核 <code>ELF</code> 文件的入口地址 <code>(Entry point)</code> ，即 <code>bootloader</code> 移动完内核后，直接跳转到的地址，由 <code>ld</code> 写入 <code>ELF</code> 的头中</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>就我个人而言，我觉得lab1的主要难点是对指导书和相关代码的阅读和理解，下面将分别从四个exercise来分析</p><h3 id="Exercise-1-1-elf"><a href="#Exercise-1-1-elf" class="headerlink" title="Exercise 1.1 : elf"></a>Exercise 1.1 : elf</h3><p>在此之前我们知道了ELF文件结构以及了解了ELF头，节头表和段头表的数据结构，我们的任务是补全代码输出ELF 文件中所有节头中的地址信息。</p><p>我觉得本exercise的难点是清楚了解ELF的文件结构，如下图所示</p><img src="/image/${fiilename}/image-20240325102203773.png" alt="image-20240325102203773" style="zoom:67%;" /><p>简单来说，ELF头中包含了段头表和节头表的信息，段头表和节头表分别含有各段和各节的信息。了解结构之后，只需要根据<code>elf.h</code>文件中的数据结构来补全代码即可。</p><h3 id="Exercise-1-2-Linker-Script"><a href="#Exercise-1-2-Linker-Script" class="headerlink" title="Exercise 1.2 : Linker Script"></a>Exercise 1.2 : Linker Script</h3><p>在了解完ELF之后，我们开始学习内核的相关知识</p><p>首先，我要需要知道内核应该被放在哪里。在 本实验的MIPS 体系结构中，4GB虚拟地址空间会被划分为 4 个大区域，如下图所示：</p><p>​<img src="/image/${fiilename}/image-20240325102830042.png" alt="image-20240325102830042" style="zoom: 67%;" /></p><p>我们的内核便被放置在<code>kseg0</code>中（具体位置可在<code>include/mmu.h</code> 中的内存布局图中查看），于是，我们就要通过<code>Linker Script</code>来将内核加载到正确的位置。在<code>Linker Script</code>我们使用<code>.</code>这一特殊符号，用来做定位计数器，根据输出节的大小增长，从而将内核<code>.text</code>、<code>.data</code>、<code>.bss</code>，这三个节的信息加载到正确位置。</p><p>在本exercise的难点我觉得是了解MIPS内存布局（一开始看到<code>mmu</code>时属实一脸懵），知道内核的位置。</p><h3 id="Exercise-1-3-start"><a href="#Exercise-1-3-start" class="headerlink" title="Exercise 1.3 : _start"></a>Exercise 1.3 : _start</h3><p>第三个exercise还算比较简单，就是首先将 <code>sp</code> 寄存器设置到内核栈空 间的位置上，随后跳转到 <code>mips_init</code> 函数</p><p>我觉得需要注意的是，因为 <code>sp</code> 是低地址增长的，所以其栈底地址就在<code>KSTACKTOP</code>，即在内核的栈在<code>0x8040 0000</code>以下的位置</p><h3 id="Exercise-1-4-printk"><a href="#Exercise-1-4-printk" class="headerlink" title="Exercise 1.4 : printk"></a>Exercise 1.4 : printk</h3><p>在第四个exercise中，我们需要实现一个printk函数，用来输出，调试（以及评测的方式）</p><p>本exercise的难点我觉得有两方面：</p><ul><li><p>变长参数表：在初次接触到变长参数时，我一开始也是看的一头雾水</p><p>根据指导书内容，在<code>stdarg.h</code> 头文件中为处理变长参数表定义了一组宏和变量类型如下：</p><ol><li><code>va_list</code>：变长参数表；</li><li><code>va_start(va_list ap, lastarg)</code>：用于初始化变长参数表的宏；</li><li><code>va_arg(va_list ap, 类型)</code>：用于取变长参数表下一个参数的宏；</li><li><code>va_end(va_list ap)</code>：结束使用变长参数表的宏。</li></ol><p>具体应用如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *fmt, ...)</span> &#123;   </span><br><span class="line">va_list ap;   <span class="comment">//声明变长参数表ap</span></span><br><span class="line">    va_start(ap, fmt);   <span class="comment">//初始化ap</span></span><br><span class="line">    <span class="type">int</span> num1 = va_arg(ap, <span class="type">int</span>);   <span class="comment">// 从ap中取出一个int型变量</span></span><br><span class="line">    <span class="type">int</span> num2 = va_arg(ap, <span class="type">int</span>);   <span class="comment">// 取出下一个int型变量</span></span><br><span class="line">    va_end(ap);   <span class="comment">//结束变长参数表ap的使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码阅读：本实验中填写代码之前，还需要阅读大量相关代码。而且代码中使用大量指针、宏定义以及文件之间的相互调用，在初次阅读时还是有不小的难度。</p><p>主要的输出逻辑是这样，在<code>printk()</code>函数中通过<code>vprintfmt(outputk, NULL, fmt, ap);</code>调用<code>vprintfmt</code>，接下来在<code>vprintfmt</code>函数中对输出形式进行判断，最后通过传入的<code>outputk</code>调用<code>printchar</code>在最底层以向一个地址写出字符数值的形式输出字符</p></li></ul><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次实验也是第一次接触到了操作系统的内部架构，对我来说还是有不小的难度。第一次阅读指导书时也是真的很懵，代码无从下手。不过随着反复阅读以及参考学长博客，最终还是顺利完成了exercise任务并基本了解内核启动相关知识。</p><p>以后实验指导书和代码的阅读难度肯定会更大，希望也可以一点点理解，一点点深入操作系统的学习。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO第一单元总结</title>
      <link href="/2024/03/21/oo-Unit1/"/>
      <url>/2024/03/21/oo-Unit1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在三周的磕磕绊绊中，也算是顺利完成了oo第一单元的三次作业。面对久仰大名的oo，虽说的确很累，但也收获良多。</p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>读入一个包含加、减、乘、乘方以及括号（其中括号的深度<strong>至多为 1 层</strong>）的<strong>单变量</strong>表达式，输出<strong>恒等变形展开所有括号后</strong>的表达式。</p><p>需求如下：</p><ol><li>处理括号</li><li>处理指数</li><li>计算加，减，乘</li><li>化简合并得到结果</li></ol><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>对于输入的一个表达式，我主要分为两步进行处理：</p><p>第一步：<strong>解析</strong>表达式，得到后缀表达式</p><p>第二步：<strong>计算</strong>后缀表达式，得到结果</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p>首先我对输入的表达式进行了一波<strong>预处理</strong>，主要就干了两件事：去空格，连续的加减号变成一个符号</p></li><li><p>然后，开始解析表达式，我在课程组在training中提供的<strong>递归下降</strong>算法的代码基础上，根据题目要求做了稍微修改，得到后缀表达式（不得不说，课程组给的代码真是救大命）</p><p>这里要提一句，由于第一次作业经验不足，我将<strong>指数</strong>在解析表达式阶段处理，也就是解析时读到一个^，就将前面的式子乘对应指数遍，比如我读到<code>(x+1)^3</code>，我就会处理成<code>(x+1)*(x+1)*(x+1)</code>，一个^还好，一旦指数嵌套，由于我存的时候没有化简合并，就会有爆时间和爆内存的风险，也是导致了我在第二次作业强测的第二个点挂掉。所以指数处理还是要在第三步计算时实现。</p></li><li><p>现在我们要对上一步得到的后缀表达式进行<strong>计算</strong>来得到最终结果。本次作业主要自己写的也就是这一部分。具体实现方式是我新建了一个Calculate类用于实现计算操作。</p><p>我们可以发现最终得到的结果是一个多项式，而其中每一个单项式都是<code>系数*x^指数</code>的形式（要注意输出时判断一下系数和指数的值看能否省略或化简），那么由于底数都是x，我们就可以用一个<code>HashMap&lt;Integer,BigInteger&gt;</code>来存储多项式，即<code>HashMap&lt;指数，系数&gt;</code>。比如<code>3*x^2+4*x^5</code>我们就可以存成<code>HashMap&lt;(2,3),(5,4)&gt;</code>同时由于指数作为<code>key</code>，我们也可以更容易的实现同类项的合并。</p><p>之后，由于我们是对后缀表达式做处理，所以可以用<code>ArrayList</code>来代表一个<strong>栈</strong>，里面存储多项式.这样在后缀表达式中读到数字或者x，我们就将其存入栈中；读到符号就取栈顶的两个多项式进行对应的加、减、乘的计算得到结果再存入栈中，当处理完后缀表达式后，栈中只剩下一个多项式，就是最终的结果了。</p></li></ol><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/image/$%7Bfiilename%7D/add2f020de3e7848130a4664f603be7-1711347086223-4.png" alt="add2f020de3e7848130a4664f603be7"></p><h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><p>由于第一次作业相对比较简单，所以优化方式也不多，在进行同类项的合并之后只需要注意一下将多项式中的首个负项放在最前面即可</p><h3 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>本次作业强测以及互测都没有出现bug，同时在互测中也没有测出别人的bug（满心期待的把别人代码丢到我的评测机里跑，跑了半天也什么bug都没有）</p><p>在本次作业中我也是第一次搭建评测机完成自动化测试，我在往届学长的评测机代码的基础上进行了稍微修改也搞出了一个自己的评测机，还算成就感满满。</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><p>第二次作业我认为是三次作业中最困难的一次，新增功能不少，同时处理指数函数对于刚刚入门oo的我也有不小的难度</p><h3 id="新增需求"><a href="#新增需求" class="headerlink" title="新增需求"></a>新增需求</h3><ol><li>支持处理嵌套多层括号</li><li>新增指数函数因子：<code>exp(因子)^指数</code></li><li>新增自定义函数因子</li></ol><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>整体流程和第一次作业一样，还是先解析得到后缀表达式，再计算后缀表达式并化简合并输出最终结果。</p><ol><li>对于处理嵌套<strong>多层括号</strong>：在第一次作业中的递归下降算法便足以解决这个问题，无需新增代码</li><li>对于<strong>自定义函数</strong>：我在预处理阶段从字符串层面对于自定义函数进行替换</li><li>对于<strong>指数函数因子</strong>：对calculate类进行重构，改变数据结构来存储新的多项式，同时改变加，减，乘的方法。</li></ol><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p><strong>自定义函数</strong>处理：我新建了一个<code>SelfDefineFun</code>类用于存放输入的自定义函数。随后在表达式预处理中，我遍历表达式，如果读到f, g, h那么就将找到完整的函数交给<code>SelfDefineFun</code>类处理，并利用在自定义函数类中写的<code>toString</code>方法得到处理之后的字符串。</p><p>这里要注意两个点：</p><p>第一个点是要注意嵌套自定义函数的情况，使用递归处理即可</p><p>第二个点是注意替换x的时候不要把exp中的x也换掉</p></li><li><p><strong>解析</strong>表达式修改：由于本次新增指数函数，所以就在递归下降中加入<code>parseExp</code>方法，位置和解析括号位置相同。</p><p>此外，我对于<code>exp()</code>后面可能存在的指数的处理方法是将指数乘进括号内，比如<code>exp(x)^2</code>就处理成<code>exp(x*2)</code>，这样就可以使我在最终输出前所有的<code>exp()</code>都没有指数，方便我对<code>exp()</code>从字符串层面进行同类项合并</p></li><li><p>重构<strong>计算</strong>类：这个可真是下了大功夫，也是写了很多面对过程编程的代码，本来打算重构的，但是第三次作业刚好用到了一部分，也就没有全改掉</p><p>和上次一样，我发现最后的多项式由相同形式的单项式组成，每个单项式都是<code>系数*x^指数*exp((多项式))</code>，于是我用<code>TreeMap&lt;String, Integer&gt;</code>来存储单项式，<code>TreeMap&lt;TreeMap&lt;String, Integer&gt;, BigInteger&gt;</code>来存储多项式，再和上次一样用一个<code>ArrayList</code>来作为计算的栈存放多项式。</p><p>具体计算就是和上一次作业大致类似，就是需要重新写加、减、乘方法来实现对指数函数的计算与合并</p></li><li><p><strong>输出</strong>：我的<strong>优化</strong>均在输出时实现，也就是在输出时判断指数和系数的值看是否需要输出，以及对exp()内的情况进行判断来确定输出方式</p></li></ol><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/image/$%7Bfiilename%7D/65127e2ec3a0bad53c8cb0975cab0ab-1711347096659-6.png" alt="65127e2ec3a0bad53c8cb0975cab0ab"></p><h3 id="优化方式-1"><a href="#优化方式-1" class="headerlink" title="优化方式"></a>优化方式</h3><p>本次优化还是有很多方面需要考虑的，我做了如下实现：</p><ol><li>第一个负项提到最前面</li><li>对于exp内部相同的进行合并</li><li><code>exp((因子))</code> -&gt; <code>exp(因子)</code></li><li><code>exp((系数*因子))</code>  -&gt; <code>exp(因子)^系数</code></li></ol><p>除了我做的这些优化之外，还有人做到了将exp()内的公因式提取到括号外，以及将一个exp()拆成两个exp()相乘。由于考虑到正确性优先以及实现其他优化对代码改动较多，我没有继续优化。</p><h3 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>很不幸，我的本次作业在强测中挂掉两个点：</p><p>第一个点是因为处理指数函数的方式错误导致面对<code>(((((((((((x^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8</code>这样的数据时出现了<code>MEMORY_LIMIT_EXCEED</code>错误。</p><p>第二个点是由于在优化时我将exp()内的系数提到括号外，但由于我之前所有的exp()都是不带指数的，所以我之前对<code>exp(因子)</code>都是直接采取<code>subString(4, exp.length() - 1)</code>的方法获取exp()内的因子，这也导致了优化后出现指数时获取因子错误。</p><p>在互测中被hack的点和强测的第二个点错误方式一样。</p><p>但同时，我在互测中也成功hack到别人三个错误：</p><ol><li>由于优化时去掉括号错误导致出现<code>exp(-x)</code></li><li>提取公因式时将负数提出到指数位置</li><li>处理自定义函数时在读入其中exp()内的因子出现错误</li></ol><p>前两个点均是通过自己捏数据来hack到的，第三个错误是利用我的评测机跑出来的，自己的评测机第一次在互测中发挥作用，感觉很不错。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><p>第三次作业确实挺简单的，抱着死磕两三天的心态开始第三次作业，结果一个晚上搞完了。虽说轻松却没有了第二次作业的激情，让这周像过博客周一样。</p><h3 id="新增需求-1"><a href="#新增需求-1" class="headerlink" title="新增需求"></a>新增需求</h3><ol><li>自定义函数定义时可以出现之前定义过的<strong>其他自定义函数</strong></li><li>新增<strong>求导因子</strong></li></ol><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><ol><li>对于自定义函数的改变很简单，就是在替换的时候再调用一下就好</li><li>求导因子我是通过化简后对需要求导的多项式的<strong>每个单项式分别进行求导</strong>处理，因为单项式有通项形式，所以实现较为容易</li></ol><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里就说说对求导的处理吧</p><ol><li><p>解析阶段：和exp()一样，我把dx()当做整体存进后缀表达式中，同时dx()里面也是后缀表达式形式</p></li><li><p>计算阶段：求导无非就是对一个表达式也就是一个多项式求导，那么多项式求导就是其中的每个单项式分别求导再相加。</p><p>我们知道单项式的通项形式为<code>系数*x^指数*exp((多项式))</code>，那么这个东西求导就是前导后不导加后导前不导，也就是<code>dx(系数*x^指数*exp((多项式)))</code>等于<code>系数*dx(x^指数)*exp((多项式)) + 系数*x^指数*dx(exp((多项式)))  </code>而对于幂函数和指数函数求导又有各自的法则，就很容易处理了。</p></li></ol><h3 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h3><img src="/image/${fiilename}/b7e920fa1a46c6f9676b0d36e949387-1711347107989-8.png" alt="b7e920fa1a46c6f9676b0d36e949387"  /><h3 id="优化方式-2"><a href="#优化方式-2" class="headerlink" title="优化方式"></a>优化方式</h3><p>由于第三次作业和第二次的输出形式可以说是一模一样，我在第二次的优化方案上并没有新增其他优化</p><h3 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>和第一周一样，我在强测和互测中均没有出现错误，同时互测房内也都没有出现bug</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>​持续三周的第一单元这么快就过去了，现在想想，前两周冥思苦想无从下手的样子仿佛还在眼前。oo不仅让我学到了面向对象编程的思想，让我的代码思路更清楚，一切为对象服务、接口封装，一段码该干嘛就干嘛，不用乱加其他功能，同时也提升了我对较大规模代码的整体设计能力以及debug能力。在之前我编写代码时可能想一点写一点，但现在，我会拿出一张纸，好好构思好好设计，思考每个类的功能以及他和其他类的关系，争取让我的设计更优雅，我的代码更清晰。</p><p>​同时，在第三周和第四周任务量很少的时候，我也老会觉得空唠唠的，可能甚至习惯了前两周的高强度oo时光了吧。所以，已经期待着下一单元了，继续探索，继续战斗，继续痛苦并快乐着！</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><p>对于第一单元修改的建议，我个人看法有以下两个方面：</p><ol><li>感觉可以修改一下cost机制，有时候很简单的数据过不了cost限制，一些相对复杂的数据又不会被限制（虽然我没仔细研究过cost机制，但在hack别人的时候是这种感受）</li><li>可以调整一下第三单元难度，从第二单元到第三单元落差有点太大了，感觉可以增加一些难度</li></ol><p>这就是我的第一单元总结了，oo第一单元完结，撒花！</p>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-lab0</title>
      <link href="/2024/03/14/OS-lab0/"/>
      <url>/2024/03/14/OS-lab0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking-0-1-：Git的状态转换"><a href="#Thinking-0-1-：Git的状态转换" class="headerlink" title="Thinking 0.1 ：Git的状态转换"></a>Thinking 0.1 ：Git的状态转换</h3><p>思考下列有关 Git 的问题：</p><ul><li>在前述已初始化的 <code>~/learnGit</code> 目录下，创建一个名为 <code>README.txt</code> 的文件。执 行命令 <code>git status &gt; Untracked.txt</code>（其中的 &gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。 </li><li>在 <code>README.txt</code> 文件中添加任意文件内容，然后使用 <code>add</code> 命令，再执行命令 <code>git status &gt; Stage.txt</code>。</li><li>提交 <code>README.txt</code>，并在提交说明里写入自己的学号。</li><li>执行命令 <code>cat Untracked.txt</code> 和 <code>cat Stage.txt</code>，对比两次运行的结果，体会 README.txt 两次所处位置的不同。</li><li>修改 <code>README.txt</code> 文件，再执行命令 <code>git status &gt; Modified.txt</code>。</li><li>执行命令 <code>cat Modified.txt</code>，观察其结果和第一次执行 <code>add</code> 命令之前的 <code>status</code> 是 否一样，并思考原因。</li></ul><p>答：</p><ul><li><p>本思考题主要探讨的问题为Git中的四种状态转换关系，如下图</p><img src="/image/${fiilename}/image-20240311104956433.png" alt="image-20240311104956433" style="zoom: 80%;" /></li><li><p>第一次查看状态时重定向到<code>Untracked.txt</code>中的输出为：</p><img src="/image/${fiilename}/image-20240311104546116.png" alt="image-20240311104546116" style="zoom: 50%;" /><p>说明此时文件处于<strong>未追踪状态</strong>（Untracked)</p></li><li><p>使用<code>add</code>命令后，第二次查看状态时的状态为：</p><img src="/image/${fiilename}/image-20240311104709625.png" alt="image-20240311104709625" style="zoom: 50%;" /><p>此时经过<code>git add</code>命令后，<code>README.txt</code>和<code>Untracked.txt</code>被添加到<strong>暂存区</strong>(Staged)</p></li><li><p>最后，提交并修改后再次查看状态：</p><img src="/image/${fiilename}/image-20240311110207393.png" alt="image-20240311110207393" style="zoom: 50%;" /><p>文件提交后处于<strong>Unmodified</strong>区，再对其进行修改后文件位于<strong>modified</strong>区</p></li><li><p>所以，对于思考题中的问题：<code>观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。</code></p><p>答案是两次的<code>status</code>是不一样的，根据我上面的分析，第一次执行<code>add</code>命令之前的<code>status</code>是<code>Untracked</code>，而最后的<code>status</code>为<code>modified</code>，所以状态不同</p></li></ul><h3 id="Thinking-0-2-：Git状态转换命令"><a href="#Thinking-0-2-：Git状态转换命令" class="headerlink" title="Thinking 0.2 ：Git状态转换命令"></a>Thinking 0.2 ：Git状态转换命令</h3><p>仔细看看下图，思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？</p><img src="/image/${fiilename}/image-20240311104956433.png" alt="image-20240311104956433" style="zoom: 80%;" /><ul><li>还是上面思考题最前面放的那张图，本思考题要我们思考图中箭头对应的指令是什么</li><li><code>add the file</code>：对应<code>git add</code>指令</li><li><code>stage the file</code> ：同样对应 <code>git add</code> 指令</li><li><code>commit</code>： 对应 <code>git commit</code> 指令</li></ul><h3 id="Thinking-0-3-：Git文件恢复"><a href="#Thinking-0-3-：Git文件恢复" class="headerlink" title="Thinking 0.3 ：Git文件恢复"></a>Thinking 0.3 ：Git文件恢复</h3><p>思考下列问题： </p><ol><li>代码文件 <code>print.c</code> 被错误删除时，应当使用什么命令将其恢复？ </li><li>代码文件 <code>print.c</code> 被错误删除后，执行了 <code>git rm print.c</code> 命令，此时应当 使用什么命令将其恢复？</li><li>无关文件 <code>hello.txt</code> 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</li></ol><p>答：</p><ol><li>执行 <code>git checkout -- printf.c</code> 指令，</li><li>先执行 <code>git reset HEAD printf.c</code> 指令，然后执行 <code>git checkout -- printf.c</code> 指令</li><li>执行 <code>git rm --cached hello.txt</code> 指令</li></ol><h3 id="Thinking-0-4：Git版本回退"><a href="#Thinking-0-4：Git版本回退" class="headerlink" title="Thinking 0.4：Git版本回退"></a>Thinking 0.4：Git版本回退</h3><p>思考下列有关 Git 的问题：</p><ul><li>找到在 <code>/home/22xxxxxx/learnGit</code> 下刚刚创建的 README.txt 文件，若不存 在则新建该文件。</li><li>在文件里加入 <code>Testing 1</code>，git add，<code>git commit</code>，提交说明记为 1。 • 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</li><li>使用 <code>git log</code> 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值a。</li><li>进行版本回退。执行命令 <code>git reset --hard HEAD^</code> 后，再执行 <code>git log</code>，观 察其变化。</li><li>找到提交说明为 1 的哈希值，执行命令 <code>git reset --hard &lt;hash&gt;</code>  后，再执行 <code>git log</code>，观察其变化。</li><li>现在已经回到了旧版本，为了再次回到新版本，执行 <code>git reset --hard &lt;hash&gt;</code>   ，再执行 <code>git log</code>，观察其变化。</li></ul><p>答：</p><ul><li><p>按照题目中前三条操作后：</p><img src="/image/${fiilename}/image-20240311143945383.png" alt="image-20240311143945383" style="zoom: 50%;" /><p>我们可以发现已经有三次提交，提交3的哈希值a为<code>13e87e5473698331de9e0c5e5b00c2ce222cc5e1</code></p></li><li><p>执行 <code>git reset --hard HEAD^</code>进行版本回退后，再执行<code>git log</code>我们发现提交日志中只剩下两次提交，如下图：</p><img src="/image/${fiilename}/image-20240311144349852.png" alt="image-20240311144349852" style="zoom:50%;" /><p>提交1的哈希值为<code>e283774abeee6b0a5d4cb2a4d1174107938254be</code></p></li><li><p>再执行<code>git reset --hard e283774abeee6b0a5d4cb2a4d1174107938254be</code>，版本再次回退，提交日志中只剩下提交1的日志</p></li><li><p>执行完上述操作以及观察到对应现象后，我认为<code>git reset</code> 指令能让我们通过不同提交对应的哈希值，移动 <code>HEAD</code> 回退到任意的版本，更新暂存区和版本库的当前版本，从而实现版本回退。但在参数为 <code>--hard</code> 的情况下会同时覆盖掉工作目录下的文件，相当于把原本的工作目录使用回退版本库中的内容也全部覆盖掉；所以若工作目录下的文件还未提交，则 <code>Git</code> 仍会覆盖它从而导致无法恢复，有一定风险，所以也要慎用。</p></li></ul><h3 id="Thinking-0-5-：echo"><a href="#Thinking-0-5-：echo" class="headerlink" title="Thinking 0.5 ：echo"></a>Thinking 0.5 ：echo</h3><p>执行如下命令, 并查看结果：</p><ul><li><code>echo first</code></li><li><code>echo second &gt; output.txt</code></li><li><code>echo third &gt; output.txt</code></li><li><code>echo forth &gt;&gt; output.txt</code></li></ul><p>答：</p><ul><li><p>执行完上面四条操作后，我们在终端看到了第一条命令执行输出的<code>first</code>，再查看<code>output.txt</code>中内容：</p><img src="/image/${fiilename}/image-20240311150737313.png" alt="image-20240311150737313" style="zoom: 80%;" /></li><li><p>我们发现只有<code>third</code>和<code>forth</code>，并没有<code>second</code>。原因是第三条命令<code>echo third &gt; output.txt</code>没有使用<code>&gt;&gt;</code>，所以将第二条命令在<code>output.txt</code>中的输出覆盖掉，而第四条使用了<code>&gt;&gt;</code>，将<code>forth</code>接在原来<code>output.txt</code>文件的末尾</p></li></ul><h3 id="Thinking-0-6-："><a href="#Thinking-0-6-：" class="headerlink" title="Thinking 0.6 ："></a>Thinking 0.6 ：</h3><p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test）， 将创建该文件的命令序列保存在 <code>command</code> 文件中，并将 <code>test</code> 文件作为批处理文件运行，将 运行结果输出至 <code>result</code> 文件中。给出 <code>command</code> 文件和 <code>result</code> 文件的内容，并对最后的结 果进行解释说明（可以从 <code>test</code> 文件的内容入手）. 具体实现的过程中思考下列问题: </p><ul><li>echo echo Shell Start 与 echo <code>echo Shell Start</code> 效果是否有区别; </li><li>echo echo $c&gt;file1 与 echo <code>echo $c&gt;file1</code> 效果是否有区别.</li></ul><img src="/image/${fiilename}/image-20240314141116512.png" alt="image-20240314141116512" style="zoom:50%;" /><p>答：</p><ul><li><p>command中内容：</p><img src="/image/${fiilename}/image-20240314143506189.png" alt="image-20240314143506189" style="zoom: 60%;" /></li><li><p>result中内容：</p><img src="/image/${fiilename}/image-20240314143621967.png" alt="image-20240314143621967" style="zoom: 80%;" /></li><li><p>问题思考：</p><ol><li>echo echo Shell Start 与 echo <code>echo Shell Start</code>效果无区别，均为输出echo Shell Start</li><li>echo echo $c&gt;file1 与 echo <code>echo \$c&gt;file1</code>效果有区别，在echo后面出现单引号时，会将单引号包裹的整体来输出</li></ol></li></ul><h2 id="二、难点分析"><a href="#二、难点分析" class="headerlink" title="二、难点分析"></a>二、难点分析</h2><h3 id="gcc相关"><a href="#gcc相关" class="headerlink" title="gcc相关"></a>gcc相关</h3><p>之前我一直在使用各种ide一键即可编译运行.c文件，但在接触操作系统之后，对.c文件的预处理，编译，汇编，链接要靠命令行来完成，也是让刚入门的我感觉到很不习惯，下面列出一些<code>gcc</code>的常用命令，也方便我自己之后忘记时查看</p><ul><li><p><code>gcc -E hello.c &gt; 1.txt</code>：只激活预处理，不生成文件（预处理一个最简单的输出hello world也会处理成几百行的代码）</p></li><li><p><code>gcc -S hello.c</code>：进行预处理，汇编操作，生成汇编文件</p></li><li><p><code>gcc -c hello.c</code>：生成<code>hello.o</code>文件，对文件进行了预处理，编译，汇编的工作</p></li><li><p><code>gcc -o hello hello.c</code>  <code>gcc -o hello hello.o</code>：进行预处理，编译，汇编，链接的工作，生成可执行文件<code>hello</code>，执行命令<code>./hello</code>即可执行</p></li><li><p><code>gcc -I ../include hello.c</code>：如果<code>hello.c</code>中引用头文件，需要使用<code>-I</code>操作</p></li></ul><h3 id="bash脚本编写"><a href="#bash脚本编写" class="headerlink" title="bash脚本编写"></a>bash脚本编写</h3><p>bash脚本是lab0的一个重点，在课上以及课下实验中均出现了编写bash脚本的题目，大致的编写样例如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bin/bash</span></span><br><span class="line"><span class="comment">#首行用于保证直接执行我们的脚本时使用 bash 作为解释器，从第二行开始行首为#代表注释</span></span><br><span class="line"><span class="comment">#bash脚本内部其实就是linux命令行的顺序执行，基础命令在预习博客中，这里不介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bash中传递参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> no parameter</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$#</span> -eq 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> one parameter : <span class="variable">$1</span></span><br><span class="line"><span class="keyword">elif</span> [<span class="variable">$#</span> -eq 2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> two parameters : <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> many patameters : $*</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#上面代码中$#代表传递的参数个数，$*用一个字符串显示传递的全部参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#while语句</span></span><br><span class="line">n=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$n</span> -le 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$n</span></span><br><span class="line"><span class="built_in">let</span> n=n+1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h3><p>在课下实验的第四题中，编写两个Makefile卡了我很长时间，最后看往年博客才彻底搞明白</p><p>Makefile的基本格式如下</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: dependencies</span></span><br><span class="line">command 1</span><br><span class="line">command 2</span><br><span class="line">...</span><br><span class="line">command n</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>target</code>可以理解为指令名字，比如<code>target</code>是<code>clean</code>，那么执行<code>make clean</code>就是执行<code>Makefile</code>中<code>clean：</code>的命令，如果只有<code>make</code>时，默认执行第一个<code>target</code></li><li><code>dependecies</code>是<code>target</code>所依赖的文件或其他<code>target</code></li><li><code>command</code>就是要执行的命令，这里要注意，虽然这里可以写很多命令，但是每条命令都是独立的，比如我的命令需要完成：打开<code>code</code>文件夹并在<code>code</code>文件夹里面再<code>make</code>。那么我需要在一条命令中写<code>cd code &amp;&amp; make</code>而不能拆成两条（这个点卡我好久）</li></ul><h3 id="Linux进阶操作"><a href="#Linux进阶操作" class="headerlink" title="Linux进阶操作"></a>Linux进阶操作</h3><p>在lab0的课上课下实验中，也遇到了一些在os预习教程中没有见过的Linux操作，比如grep, sed, awk等文件处理操作，在刚刚使用时也是有不小的难度，具体使用细节可以在指导书中查看。</p><h2 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h2><p>总的来说，lab0的难度并不大，对我个人而言，难点在于对新工具的适应。比如，我觉得在bash脚本中对变量赋值本该是一件很简单的事，在课上extra中却一直毫无头绪；此外，对于awk等新操作的运用更是极其不熟练，只会一点最基本的操作，希望在之后的学习中可以慢慢用熟。</p><p>不过，对于刚刚接触操作系统，刚刚基础Linux命令的我来说，一切东西都是很新奇，实现很多新的操作也觉得很好玩，希望在之后的实验中也可以一直保持这样的心态，保持好奇，继续探索操作系统的世界。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS预习</title>
      <link href="/2024/02/25/OS%E9%A2%84%E4%B9%A0/"/>
      <url>/2024/02/25/OS%E9%A2%84%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul><li><p><strong>cd</strong></p><p>用法：<code>cd 目录</code></p><p>作用：切换到该目录（类似于打开文件夹）</p><p><code>cd /</code>：&#x2F; 代表根目录，即Linux文件系统的最顶层<br><code>cd ~</code>：~当前用户主目录，对于一般用户，主目录是<code>/home/用户名</code>；如果当前用户是系统管理员(root)用户，主目录是<code>/root</code><br><code>cd /etc/test</code>：切换到<code>etc</code>目录下的<code>test</code>目录（可以理解为打开<code>test</code>文件夹）</p><p><code>cd test</code>：cd命令支持相对路径，如果系统在<code>etc</code>目录，可以输入<code>cd test</code>直接访问<code>test</code>目录</p><p><code>cd .</code>：<code>.</code>表示当前目录<br><code>cd ..</code>：<code>..</code>表示上一级目录<br><code>cd -</code>：<code>-</code>表示上一次访问的目录</p></li><li><p><strong>ls</strong></p><p>用法：<code>ls [选项] [目录]</code> （<code>[]</code>代表可有可无）</p><p>作用：列出目录中的文件</p><p>常用选项：</p><p>​<code>-a</code>：显示隐藏的文件（文件名以 <code>.</code> 开头的文件）</p><p>​<code>-l</code>：每行只列出一个文件</p></li><li><p><strong>mkdir</strong></p><p>用法：<code>mkdir 目录</code></p><p>作用：创建一个新目录</p></li><li><p><strong>pwd</strong></p><p>用法：<code>pwd [选项]</code></p><p>作用：输出当前目录的绝对路径</p></li><li><p><strong>rmdir</strong></p><p>用法：<code>rmdir [选项] 目录</code></p><p>作用：删除一个空的目录。注意：只能是空目录</p></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件操作的对象是几乎所有文件，也包含目录</p><ul><li><p><strong>touch</strong></p><p>用法：<code>touch [选项] 文件名</code></p><p>作用：当文件不存在时创建新文件，当文件存在时更新文件的时间戳</p><p>注意：不能用<code>touch</code>新建目录，要使用<code>mkdir</code></p></li><li><p><strong>rm</strong></p><p>用法：<code>rm [选项] 文件</code></p><p>作用：删除文件</p><p>常用选项：</p><p>​<code>-r</code>：递归删除目录及其内容，删除非空目录必须有此选项，否则无法删除</p><p>​<code>-f</code>： 强制删除，不提示用户确认，忽略不存在的目录</p><p>​<code>-i</code>： 逐一提示用户确认每个将要被删除的文件</p><p>注意：<code>rm -rf</code>一定慎用，全删了，非必要不使用</p></li><li><p><strong>cp</strong></p><p>用法：<code>cp [选项] 源文件 目标路径</code></p><p>作用：将源文件（或目录）复制到目标路径对应的文件或目录</p><p>常用选项：</p><p>​<code>-r</code>：递归移动目录及其子目录内的所有内容</p></li><li><p><strong>mv</strong></p><p>用法：<code>mv [选项] 源文件 目标路径</code></p><p>作用：类似于剪切，将源文件移动至目标位置</p><p>常用选项：</p><p>​<code>-r</code>：递归移动目录及其子目录内的所有内容</p><p><code>mv</code>也可以用来重命名文件比如<code>mv test.txt test2.txt</code>就可以实现对<code>test.txt</code>的重命名</p></li><li><p><strong>diff</strong></p><p>用法：<code>diff [选项] 文件1 文件2</code></p><p>作用：比较两个纯文本文件的差异</p><p>常用选项：</p><p>​<code>-b</code>：不检查空白字符的不同</p><p>​<code>-B</code>：不检查空行</p><p>​<code>-q</code>：仅显示有无差异，不显示详细信息</p></li><li><p><strong>vim</strong></p><p>Vim是Linux系统下的一款开源编辑器，编辑效率很高，下面介绍Vim的基本输入操作</p><p>用法：</p><ol><li><code>vim 文件名</code></li><li>按<code>I</code>进入插入模式，可以开始输入文本内容</li><li>完成文件修改后，按<code>Esc</code>回到命令模式，再按<code>Shift + ;</code>进入底线命令模式，可以看到最后一行出现冒号。输入<code>w</code>并按回车可以保存文件，输入<code>q</code>并按回车可以关闭文件，也可以合并输入<code>wq</code>即可保存并关闭文件</li></ol></li></ul><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><ul><li><p><strong>find</strong></p><p>用法：<code>find [路径] 选项</code></p><p>作用：在给定路径下递归地查找文件，输出符合要求的文件的路径。如果没有给定路径，则在当前目录下查找。</p><p>常用选项： </p><p>​<code>-name 文件名</code> ：指定需要查找的文件名。</p><p>例如在当前目录下查找所有名为<code>test.c</code>文件的操作为<code>find -name test.c</code></p></li><li><p><strong>grep</strong></p><p>用法：<code>grep [选项] PATTERN FILE</code>（PATTERN是匹配字符串，FILE是文件或目录的路径） </p><p>作用：输出匹配字符串PATTERN的文件和相关的行</p><p>常用选项：</p><p>​<code>-a</code>：不忽略二进制数据进行搜索</p><p>​<code>-i</code>：忽略大小写差异</p><p>​<code>-r</code>：从目录中递归查找</p><p>​<code>-n</code>：显示行号</p></li><li><p><strong>tree</strong></p><p>用法：<code>tree [选项] [目录名]</code></p><p>作用：高级版的<code>ls</code>，输出目录下的文件树</p><p>常用选项：</p><p>​<code>-a</code>：列出全部文件（包含隐藏文件）</p><p>​<code>-d</code>：只列出目录</p></li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li><p><strong>man</strong></p><p>用法：<code>man [选项] 命令</code> 阅读完毕后按<code>Q</code>退出</p><p>作用：查看该命令的详细说明手册</p></li><li><p><strong>echo</strong></p><p>用法：<code>echo 要输出内容</code></p><p>作用：直接在终端输出内容</p></li></ul><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li><code>Ctrl + C</code>：终止当前程序执行。注意：在终端复制时就老老实实用右键复制，以免误杀进程。</li><li><code>Ctrl + Z</code>：挂起当前程序，暂停，放到后台<code>Ctrl + Z</code>挂起程序后会显示该程序挂起编号，若想要恢复该程序可以使用 <code>fg [job_spec]</code>即可，<code>job_spec</code> 即为挂起编号，不输入时默认为最近挂起进程。</li><li><code>Ctrl + D</code>：终止输入，在标准输入中输入<code>Ctrl+D</code>也意味着输入了一个 EOF。</li><li><code>Ctrl + L</code>：清屏，相当于命令<code>clear</code>。</li><li><code>方向键 上 下</code>：切换最近使用过的命令。</li></ul><h1 id="相关实用工具"><a href="#相关实用工具" class="headerlink" title="相关实用工具"></a>相关实用工具</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC包含了著名的 C 语言编译器 gcc</p><p>用法：<code>gcc [选项] 源代码文件</code></p><p>作用：编译该文件</p><p>我们可以先输入<code>gcc hello.c</code>编译<code>hello.c</code>文件并在目录下出现<code>a.out</code>文件，我们再通过命令<code>./a.out</code>执行<code>a.out</code>文件获得输出（注意：一定要有<code>./</code>）</p><h2 id="构建并编译运行一个-c文件"><a href="#构建并编译运行一个-c文件" class="headerlink" title="构建并编译运行一个.c文件"></a>构建并编译运行一个.c文件</h2><ol><li><code>cd 目标目录</code>：决定一个存.c文件的位置，打开该目录</li><li><code>touch 名字.c</code>：新建一个.c文件</li><li><code>vim 名字.c</code>：编辑.c文件（相关vim操作见上）</li><li><code>gcc -o &quot;可执行文件名字&quot; 名字.c</code>：编译.c文件，并给生成的可执行文件起个名字</li><li><code>./可执行文件名字 &lt; in.txt &gt; out.txt</code>：执行可执行文件，并利用重定向获取输入和输出（<code>in.txt</code>需要提前建好。<code>out.txt</code>如果原来没有，会自动生成，有了会覆盖掉原来的）</li></ol><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git-中文件的四种储存状态"><a href="#Git-中文件的四种储存状态" class="headerlink" title="Git 中文件的四种储存状态"></a>Git 中文件的四种储存状态</h2><p>一个文件，在 Git 目录中有以下四种状态：</p><ul><li>未跟踪（Untracked）：一个文件在储存库的版本信息中没有被记录过。比如在储存库中新建了一个文件，这个文件现在就是未跟踪的状态；在一个非空目录下使用 <code>git init</code> 来初始化一个空储存库，此时这个目录下的所有文件都处于未跟踪的状态。</li><li>未修改（Unmodified）：一个文件在跟踪之后一直没有改动过，或者改动已经被提交（即工作区的内容和储存库中的内容相同），则处于未修改状态。当我们修改这个文件时，则会使这个文件变成已修改状态。</li><li>已修改（Modified）：一个文件已经被修改（即工作区的内容和储存库中的内容不同），但还没有加入（<code>git add</code>) 到暂存区中。</li><li>已暂存（Staged）：一个文件已被加入暂存区。加入暂存区意味着将一个已修改的文件加入下次提交（<code>git commit</code>）需要存入储存库的文件清单中。</li></ul><p><img src="/image/$%7Bfiilename%7D/image-20240225232606403.png" alt="image-20240225232606403"></p><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><ul><li><p><code>git init</code>：把当前目录变成一个空的 Git 仓库，这样就可以对当前目录下的内容进行版本管理了。</p></li><li><p><code>git clone</code>：“克隆”一个已有的储存库到当前目录下。通常我们会从一个互联网地址（即 URL，统一资源定位符）进行克隆，所以一般这种操作可以理解为“下载”。</p></li><li><p><code>git status</code>：查看当前分支的状态，以及当前工作区的变动和暂存区的内容，便于我们对工作区的概况进行掌握。</p></li><li><p><code>git add</code>：把一个新文件或者已经修改过的文件加入暂存区中。在你完成一部分实验内容之后，可以使用<code>git add .</code> 将所有修改加入暂存区，也可以使用 <code>git add &lt;filename&gt;</code> 来将指定的文件加入暂存区。</p></li><li><p><code>git restore</code>：我们在修改一个文件之后，可能想要放弃这个修改。当这个文件还没有通过 <code>git add</code> 加入暂存区时，我们可以使用 <code>git restore &lt;filename&gt;</code> 来撤销对这个文件的修改，使其退回到上一个 commit 的状态。如果这个文件已经加入了暂存区，我们可以通过 <code>git restore --staged &lt;filename&gt;</code> 来取消暂存。</p></li><li><p><code>git checkout</code>：这个命令涉及到分支的知识，使用 <code>git checkout lab&lt;x&gt;</code> 可以切换到相应的分支。注意，在切换时，需要保证目前所有文件的状态均为“未修改”（没有修改过，或者已经提交）。</p></li><li><p><code>git commit</code>：使用 <code>git commit -m &lt;message&gt;</code> 这个命令将暂存区的修改提交到储存库中。当 message 参数有空格时需要把 message 用引号括起来。在提交时，要求给出一段说明性文字。这段文字可以任意填写，但建议按照提交内容填写，以保证多人协作时的可读性。</p></li><li><p><code>git push</code>：将本地的 commit 推送到一个远程仓库。</p></li><li><p><code>git pull</code>：将远程新建的分支下载到本地，并且将远端的更改合并到当前的分支。在利用评测机进行实验分支的初始化之后，可以在开发机中使用这个命令来将新的分支下载到本地。</p><p><img src="/image/$%7Bfiilename%7D/image-20240225232151061.png" alt="image-20240225232151061"></p></li></ul><p>​<img src="/image/$%7Bfiilename%7D/image-20240225232215486.png" alt="image-20240225232215486"></p><p>在这里贴一张gitlab上关于git操作的说明，感觉还较为全面</p><p>常用操作就是：</p><ol><li><p>先<code>git clone 上传目标库的ssh</code></p></li><li><p>将想要上传的文件拖进<code>git clone</code>出的文件夹中</p></li><li><p><code>git add .</code></p></li><li><p><code>git commit -m &quot;提交说明&quot;</code></p></li><li><p><code>git push</code></p><p>这样就可以将我们要上传的文件成功上传到库中了</p></li></ol><p><img src="/image/$%7Bfiilename%7D/fda83e04fcb352a17c3fc3a3295f7d4.png" alt="fda83e04fcb352a17c3fc3a3295f7d4"></p><h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><h2 id="shell脚本执行"><a href="#shell脚本执行" class="headerlink" title="shell脚本执行"></a>shell脚本执行</h2><p>Shell 脚本执行时，如果没有权限，我们可以使用下面的命令手动添加“执行”权限。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">chmod +x 文件名</span><br></pre></td></tr></table></figure><h2 id="Bash-Shell-语法基础"><a href="#Bash-Shell-语法基础" class="headerlink" title="Bash Shell 语法基础"></a>Bash Shell 语法基础</h2><p>首先用 <code>touch</code> 命令创建一个新文件 <code>hello.sh</code>，使用 Vim 输入以下内容：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#My first Shell script!</span><br><span class="line"><span class="built_in">echo</span> &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure><p>第一行：指定脚本的默认运行程序（即解释器）。在这里指定为 bash，这是我们最常使用的脚本运行程序。</p><blockquote><p>其中，<code>#!</code> 出现在脚本文件的第一行的前两个字符，被称为 Shebang。当文件中存在 Shebang 的情况下，程序加载器会分析 Shebang 后面的内容，并且将这些内容作为脚本文件的解释器。</p></blockquote><p>第二行：注释。注释以 <code>#</code> 开头。</p><p>第三行：输出。将 <code>echo</code> 命令后面的字符串输出。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义方式为：<code>var_name=value</code>（注意：&#x3D; 两边<strong>不允许有空格</strong>）</p><p> 使用<code>$var_name</code> 可以获取变量的值。在使用时，建议在变量名的两端加一个花括号（形如 <code>$&#123;var_name&#125;</code>），以帮助解释器识别变量的边界，避免歧义。</p><p>例如：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">str=&quot;Hello, world!&quot;</span><br><span class="line"><span class="built_in">echo</span> $str</span><br></pre></td></tr></table></figure><h3 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h3><p>我们将<code>hello.sh</code>的内容修改为：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">str=&quot;Hello, $<span class="number">1</span> and $<span class="number">2</span>!&quot;</span><br><span class="line"><span class="built_in">echo</span> $str</span><br></pre></td></tr></table></figure><p>再输入<code>$ ./hello.sh world OS</code>我们可以得到<code>Hello, world and OS!</code>即用执行命令中的<code>world</code>和<code>OS</code>替代脚本中的<code>$1</code>和<code>$2</code></p><p>如果命令中的参数不够，则不输出脚本中多出来的脚本参数；</p><p>除了 <code>$1</code>、<code>$2</code> ，还有一些其他的特殊变量：</p><ul><li><code>$#</code> ：传递的参数个数；</li><li><code>$*</code>：一个字符串，内容是传递的全部参数。</li></ul><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><ul><li><p><strong>if 语句</strong></p><p><code>if</code> 语句块的格式如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line">then</span><br><span class="line">    command11</span><br><span class="line">    command12</span><br><span class="line">    ......</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    command21</span><br><span class="line">    command22</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command31</span><br><span class="line">    command32</span><br><span class="line">    ......</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中，<code>fi</code> 是“if”的倒写，代表 <code>if</code> 语句块的结束；<code>elif</code> 意为“else if”。<code>elif</code> 和 <code>else</code> 可以按需省略。</p><p>下面举例说明：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">if</span> (( $<span class="number">1</span> &gt; $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first &gt; second&quot;</span><br><span class="line">elif (( $<span class="number">1</span> &lt; $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first &lt; second&quot;</span><br><span class="line">elif (( $<span class="number">1</span> == $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first == second&quot;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> &quot;I don&#x27;t know...&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中 <code>(())</code> 是用于比较<strong>整数</strong>之间大小的表达方式。传入字符串或浮点数，则是未定义的行为。</p></li><li><p><strong>while语句</strong></p><p><code>while</code> 语句块的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>其中 <code>done</code> 表示“do”语句块的结束。下面举例说明。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="built_in">mkdir</span> files</span><br><span class="line"><span class="built_in">cd</span> files</span><br><span class="line">i=<span class="number">1</span></span><br><span class="line">while (($i &lt;= $<span class="number">1</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        touch &quot;file$i.txt&quot;</span><br><span class="line">        let i=i+<span class="number">1</span> # or i=$((i+<span class="number">1</span>))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这里，<code>let</code> 是为变量赋值的命令，与之等价地，也可以使用 <code>i=$((i+1))</code>。</p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Shell 脚本也支持<strong>函数</strong>。函数的定义方式如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">function fun_name() &#123;</span><br><span class="line">    body...</span><br><span class="line">    return int_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>function</code> 和 <code>()</code> 可以省略其中一个。其中返回语句是可选的，函数可以不返回值。<code>int_value</code> 是一个0 - 255之间的整数，返回其他值是未定义的行为，一般会返回一个错误的结果。</p><p>函数的调用方法如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">fun_name param1 param2 ... paramN</span><br></pre></td></tr></table></figure><p>其中第 N 个参数在函数体内使用 <code>$N</code> 来获取，且不需要在函数定义开头声明。值得注意的是，当 N&gt;&#x3D;10 时，需要用 <code>$&#123;N&#125;</code> 来获取参数，否则 <code>$</code> 只会带第一位数字。如果函数有返回值，则在函数调用的后面需要使用 <code>$?</code> 获取返回值。例子如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">function fun1() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;Hello, world!&quot;</span><br><span class="line">&#125;</span><br><span class="line">function fun2() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;I&#x27;ve got &quot;$<span class="number">1</span>&quot; and &quot;$<span class="number">2</span>&quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">function fun3() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;I&#x27;m computing first + second!&quot;</span><br><span class="line">        return $(($<span class="number">1</span> + $<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line">fun1</span><br><span class="line">fun2 <span class="number">2</span> <span class="number">3</span></span><br><span class="line">fun3 <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> &quot;The sum is &quot;$?&quot;.&quot;</span><br></pre></td></tr></table></figure><p>其中，<code>$(($1 + $2))</code> 的意思是先计算 <code>$1 + $2</code> 的值。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机——蓝桥杯备赛</title>
      <link href="/2024/02/23/%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/"/>
      <url>/2024/02/23/%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>蓝桥杯比赛指定单片机跟51单片机差不多，可以通过淘宝国信长天购买。</p><p>本次学习跟着<a href="https://www.bilibili.com/video/BV1Bt41187hw/?vd_source=59e4e13f0e1002ef3a96e7a6170a57aa">b站小蜜蜂老师的视频</a></p><p>使用的相关软件为 <code>keil4</code> 和 <code>STC-ISP</code></p><h1 id="相关软件使用"><a href="#相关软件使用" class="headerlink" title="相关软件使用"></a>相关软件使用</h1><p><code>keil4</code>作用是编写代码和编译</p><p><code>STC-ISP</code>的作用是将<code>keil4</code>得到的16进制码下载到我们的板子上</p><h2 id="keil4使用"><a href="#keil4使用" class="headerlink" title="keil4使用"></a>keil4使用</h2><ol><li>选一个位置存代码，新建文件夹</li><li>打开<code>keil4</code>，顶栏选择<code>Project</code>，再选择第一个<code>New Project</code>，找到刚才建的文件夹，自己写一个项目名，然后在<code>Atmel</code>中找到<code>AT89C52</code></li><li>新建c文件，保存在刚才建的项目文件夹中</li><li>在左侧项目栏中右键项目文件夹，找到<code>add</code>什么那个，然后把建的c文件加进去</li><li>改成16进制输出</li><li>写代码，编译</li></ol><h2 id="STC-ISP使用"><a href="#STC-ISP使用" class="headerlink" title="STC-ISP使用"></a>STC-ISP使用</h2><ol><li>点打开程序文件，打开要下载到板子上的.hex文件</li><li>点下载&#x2F;编程</li><li>按板子上的下载按钮完成下载</li></ol><hr><p>下面我们实现各个元件的控制</p><h1 id="各个基本元件控制"><a href="#各个基本元件控制" class="headerlink" title="各个基本元件控制"></a>各个基本元件控制</h1><h2 id="LED指示灯的控制"><a href="#LED指示灯的控制" class="headerlink" title="LED指示灯的控制"></a>LED指示灯的控制</h2><p>在蓝桥杯指定单片机上已经有了诸多外设，传感器等等，板子的内部电路固定。所以需要通过特定的电路来对电路原件做相应的控制，而不像大一的电子设计课一样需要自己连线，可以自己定每条线插在哪个口。</p><h3 id="电路部分"><a href="#电路部分" class="headerlink" title="电路部分"></a>电路部分</h3><p>板子上共有8个我们需要控制的LED，由一个三八译码器74HC138，一个锁存器74HC573，和或非门构成，而我们就需要通过改变这几个原件的输入输出从而控制LED亮灭，那我们一一来看一看电路图。</p><ul><li><strong>三八译码器（74HC138）</strong></li></ul><img src="/image/${fiilename}/ca6b90b2e3077bcbd1fb46538f3fa3b.png" alt="ca6b90b2e3077bcbd1fb46538f3fa3b" style="zoom:150%;" /><p>​简单的三八译码器，有三个输入控制对应的八个输出，符合二进制规律</p><p>​注意的是，该三八译码器八路输出中只有一路是Low，其他都是High</p><p>​P25, P26, P27连接HC138的 A, B, C输入端，分别对应二进制的第0位，第1位和第2位</p><p>​本次控制LED我们需要让Y4为Low，所以我们要让CBA为100时，此时二进制对应为4即Y4为Low，其余输出均为High</p><ul><li><strong>锁存器（74HC573）</strong></li></ul><p><img src="/image/$%7Bfiilename%7D/e2489def9312e404eaac29046a99369.png" alt="e2489def9312e404eaac29046a99369"></p><p>​有用的只有图中Y4C输入：</p><p>​Y4C为High，那么八个输出和八个输入保持一致（输出跟着输入随时变）</p><p>​Y4C为Low，那么八个输出并不改变（输出不跟着输入变，还是原来的输出值）</p><p>​那么Y4C是啥呢？如下：</p><img src="/image/${fiilename}/dbc69a7aff4b84f57d8a8c082498a4c.png" alt="dbc69a7aff4b84f57d8a8c082498a4c" style="zoom:200%;" /><p>​图有点糊，但没啥事</p><p>​WR一般都是0，Y4和Y4C相反</p><p>​所以在上面我们让CBA是100，Y4为Low，那么Y4C就是High，此时我们就可以顺利通过P0^1到8来控制八个小灯泡了，0为亮，1为灭，即P0 &#x3D; 0x00代表8个小灯泡全亮，P0 &#x3D; 0xff代表8个小灯泡全灭。</p><p>至此，有关LED的电路部分介绍完毕，我们开始进行代码的编写。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>整个51单片机编程使用的都是C语言，很好上手</p><ul><li><p>引入头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul><p>​引入此头文件之后我们可以用特定字母代表指定引脚，比如P2^5代表电路图中的P25</p><ul><li><p>对应引脚定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit HC138_A = P2^<span class="number">5</span>;</span><br><span class="line">sbit HC138_B = P2^<span class="number">6</span>;</span><br><span class="line">sbit HC138_C = P2^<span class="number">7</span>;</span><br></pre></td></tr></table></figure></li><li><p>延迟函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​每个延迟函数都这么写就行</p><ul><li><p><strong>LED控制函数</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LEDRunning</span><span class="params">()</span>&#123;   </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">//Y4 = 0</span></span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//跑马灯</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)&#123;</span><br><span class="line">P0 = <span class="number">0xff</span> &lt;&lt; i;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)&#123;</span><br><span class="line">P0 = ~(<span class="number">0xff</span> &lt;&lt; i);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8个LED整体闪三下</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0xff</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">LEDRunning();</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简简单单主函数，不断循环LED控制函数</p></li></ul><p>编写完代码下载到板子上，进行验证以及修改</p><p>至此，我们就可以顺利控制LED了</p><h2 id="继电器和蜂鸣器"><a href="#继电器和蜂鸣器" class="headerlink" title="继电器和蜂鸣器"></a>继电器和蜂鸣器</h2><h3 id="电路部分-1"><a href="#电路部分-1" class="headerlink" title="电路部分"></a>电路部分</h3><p><img src="/image/$%7Bfiilename%7D/055e11268c30d61c5937a455b638d2d.png" alt="055e11268c30d61c5937a455b638d2d"></p><p>如图，<code>N_RELAY</code>连的是继电器，<code>N_BUZZ</code>连的是蜂鸣器，相对应的输入分别是P04和P06，输入为High时工作。</p><p>和上面LED不同，与锁存器相连的是Y5C，所以要控制继电器和蜂鸣器，我们需要使74HC138的输出Y5为Low，其他输出为High，即CBA为101；</p><h3 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h3><ul><li><p>代码优化</p><p>由于本次涉及到了Y5C，我们可以写一个函数来决定HC138的输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(n)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">1</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">1</span>;</span><br><span class="line">HC138_A = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个函数，我们只需一个数字便可以得到我们想要的输出从而选择控制哪部分电路</p></li><li><p>控制继电器和蜂鸣器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继电器吸合</span></span><br><span class="line">InitHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x10</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蜂鸣器叫一下</span></span><br><span class="line">InitHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x40</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="共阳数码管"><a href="#共阳数码管" class="headerlink" title="共阳数码管"></a>共阳数码管</h2><p><img src="/image/$%7Bfiilename%7D/image-20240225160400292.png" alt="image-20240225160400292"></p><p>如图，Y6C控制数码管位置，Y7C控制数码管内容</p><p>Y6C: P0^0-7与com0-7相连，控制8个数码管的明灭</p><p>Y7C: 每个数字或字母由组成数码管的8个LED决定，对应如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SMG_duanma[<span class="number">18</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>,</span><br><span class="line">                                <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>,</span><br><span class="line">                                <span class="number">0x88</span>, <span class="number">0x80</span>, <span class="number">0xc6</span>, <span class="number">0xc0</span>, <span class="number">0x86</span>,</span><br><span class="line">                                <span class="number">0x8e</span>, <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h3><p>由于控制数码管内容的只有P0^1-7，所以在静态显示中，如果有多个数码管同时亮，则显示的内容一致</p><ul><li><p>数码管位置及内容控制函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowSMG_Bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat, <span class="type">unsigned</span> pos)</span>&#123;</span><br><span class="line"> <span class="comment">//数码管位置</span></span><br><span class="line">InitHC138(<span class="number">6</span>);</span><br><span class="line">P0 = <span class="number">0x01</span> &lt;&lt; pos;</span><br><span class="line"><span class="comment">//数码管内容</span></span><br><span class="line">InitHC138(<span class="number">7</span>);</span><br><span class="line">P0 = SMG_duanma[dat]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>8个数码管依次亮</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SMG_Static</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line"> ShowSMG_Bit(i,i);  </span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态显示"><a href="#动态显示" class="headerlink" title="动态显示"></a>动态显示</h3><p>动态显示是根据人眼的<strong>视觉暂留现象</strong>以及发光二极管的<strong>余晖效应</strong>，只要8个LED闪的够快，那么在看起来就是一直亮的。</p><p>动态显示可以大大节省I&#x2F;O端口，而且功耗低</p><ul><li><p>动态显示代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SMG_Dynamic</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;   </span><br><span class="line">ShowSMG_Bit(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">Delay(<span class="number">500</span>);  </span><br><span class="line">    <span class="comment">//延迟也不能太短，LED点亮也需要时间，太短会让数码管看起来很暗</span></span><br><span class="line">ShowSMG_Bit(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">Delay(<span class="number">500</span>); </span><br><span class="line">ShowSMG_Bit(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">3</span>,<span class="number">3</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">4</span>,<span class="number">4</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">5</span>,<span class="number">5</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">6</span>,<span class="number">6</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">7</span>,<span class="number">7</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态显示的延迟函数</p><p>动态显示的延迟函数不能像之前的一样，而应该在延迟函数的<code>while</code>函数中一直进行动态显示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_Dynamic</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(t--)&#123;</span><br><span class="line"> SMG_Dynamic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">SMG_Static();</span><br><span class="line">SMG_Dynamic();</span><br><span class="line">Delay_Dynamic(<span class="number">100</span>);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​这样我们就可以随意控制8个数码管显示任何数字以及实现我们想要完成的变化了</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><h3 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h3><p>单个独立按键内部结构如下图所示，按下按键时输出低电平（接地），松开输出高电平（接VCC电源了）</p><img src="/image/${fiilename}/image-20240226182037139.png" alt="image-20240226182037139" style="zoom:50%;" /><p>独立按键共有四个：S7, S6, S5, S4，电路图如下所示，其中最左侧一列四个为独立按键</p><p><img src="/image/$%7Bfiilename%7D/image-20240226175148420.png" alt="image-20240226175148420"></p><p>将<code>J5</code>跳帽连接2,3引脚切换至独立按键模式</p><p>4个独立按键电路非常简单，P3^0-3依次连接独立按键的S7, S6, S5, S4</p><p>在代码中只需将S与P3相对应：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit S7 = P3^<span class="number">0</span>;</span><br><span class="line">sbit S6 = P3^<span class="number">1</span>;</span><br><span class="line">sbit S5 = P3^<span class="number">2</span>;</span><br><span class="line">sbit S4 = P3^<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在按键操作的代码中，我们需要做去抖动处理，从而识别有效按键，比如下面代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(S7 == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line">L1 = <span class="number">0</span>；</span><br><span class="line">            <span class="keyword">while</span>(S7 == <span class="number">0</span>);</span><br><span class="line">            L1 = <span class="number">1</span>；</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过使用<code>Delay(100)</code>实现了去抖动。</p><p>S7按下则L1亮，松开则灭</p><p>同时，我们用独立按键控制灯泡明灭会遇到两种情况：第一种情况就是上述的按下灯亮，松开灯灭；第二种就是按下灯亮，松开灯不灭，再次按下该按键灯才灭。第二种情况可以如下实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sta表示当前状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (sta == <span class="number">0</span>)&#123;</span><br><span class="line">sta = <span class="number">1</span>;</span><br><span class="line">L1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sta == <span class="number">1</span>)&#123;</span><br><span class="line">sta = <span class="number">0</span>;</span><br><span class="line"> L1 = <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(S7 == <span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码<code>if</code>判断的最后，我们使用了<code>while(S7 == 0);</code>从而避免按S7的时候程序反复进入该<code>if</code>判断中，这样可以使得按一下按键只进入一次<code>if</code>判断语句。</p><h3 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h3><p><strong>电路部分</strong></p><p>将<code>J5</code>跳帽连接1,2引脚切换至矩阵键盘模式</p><img src="/image/${fiilename}/image-20240226185144689.png" alt="image-20240226185144689" style="zoom:50%;" /><p>与独立按键不同，矩阵键盘左端不接地，而是连接I&#x2F;O输入，当左端输入为0且右端输出为0时，说明该按键被按下</p><p>所以，我们需要扫描按键，即逐行接低电平，检测每列输出，输出低电平则可以锁定行列坐标</p><p><img src="/image/$%7Bfiilename%7D/image-20240226175148420.png" alt="image-20240226175148420"></p><p><strong>代码部分</strong></p><p>首先，我们将行用R1-4表示，列用C1-4表示（由于我们引用的<code>reg52.h</code>头文件中没有P4端口，所以我们需要提前定义一下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义P4口， 电路图中P36为P42，P37为P44</span></span><br><span class="line">sfr P4 = <span class="number">0xc0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//R代表矩阵行，C代表矩阵列</span></span><br><span class="line">sbit R1 = P3^<span class="number">0</span>;</span><br><span class="line">sbit R2 = P3^<span class="number">1</span>;</span><br><span class="line">sbit R3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit R4 = P3^<span class="number">3</span>;</span><br><span class="line">sbit C4 = P3^<span class="number">4</span>;</span><br><span class="line">sbit C3 = P3^<span class="number">5</span>;</span><br><span class="line">sbit C2 = P4^<span class="number">2</span>;</span><br><span class="line">sbit C1 = P4^<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>然后，我们开始逐行扫描矩阵键盘</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeyMul</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//第一行</span></span><br><span class="line">R1 = <span class="number">0</span>;</span><br><span class="line">R2 = R3 = R4 = <span class="number">1</span>; </span><br><span class="line">C1 = C2 = C3 = C4 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (C1 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C1 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C2 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C2 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C3 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C3 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C4 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C4 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二、三、四行同理，复制粘贴略加改动即可</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们便可以确定哪个按键被按下，同时在对应的if判断语句中写下我们要进行的操作即可实现矩阵键盘相关的控制。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>在单片机中，内设和外设的主要交互方式有两种：轮询和中断，中断的相关原理跟计组中的中断一样</p><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>在51单片机中，有5个中断源（要记住每个中断源对应的终端号0-4）：</p><ol start="0"><li><p><code>INT0</code>：外部中断0</p></li><li><p><code>IF0</code>：定时&#x2F;计数器0</p></li><li><p><code>INT1</code>：外部中断1</p></li><li><p><code>IF0</code>：定时&#x2F;计数器1</p></li><li><p><code>R1/T1</code>：串口中断</p></li></ol><p>中断系统结构如下图所示：</p><p><img src="/image/$%7Bfiilename%7D/image-20240302140049460.png" alt="image-20240302140049460"></p><p>按照该图从左到右的顺序：</p><ul><li>最左段的表示五个中断源相应的输入</li><li><code>IT0</code>和<code>IT1</code>置1时表示响应下降信号，置0表示响应高电平</li><li>在<code>IE</code>寄存器中，EA表示中断总开关，如果想要相应中断，EA必须置1；EA左边的那五个则对应五个中断源各自的开关，同样置1相应</li><li><code>IP</code>寄存器用来设置相应优先级，一般用不到</li></ul><h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>一般情况下，中断的处理函数有两个，一个是中断初始化函数，一个是中断服务函数</p><p><strong>中断初始化函数</strong></p><p>其实就是对中断相关开关进行赋值，初始化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init_INT0</span><span class="params">()</span> &#123;</span><br><span class="line"> IT0 = <span class="number">1</span>;</span><br><span class="line"> EX0 = <span class="number">1</span>;</span><br><span class="line"> EA = <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在主函数里最前面引用一下即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Init_INT0();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">Working();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中断服务函数</strong></p><p>中断服务函数有特殊格式要求：</p><p><code>void 函数名() interrupt 中断号</code></p><p>比如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ServiceINT0</span><span class="params">()</span> interrupt 0  &#123;</span><br><span class="line">L8 = <span class="number">0</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">   L8 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以实现中断处理了</p><p>单片机默认的<code>INT0</code>中断对应的按键为<code>S5</code>，要注意将<code>J5</code>跳帽链接23引脚</p><p>这样当我们按下<code>S5</code>时，我们会发现板子停止原来的工作，开始执行中断服务函数中我们设定的操作，当设定操作完成，板子又会继续原来的工作，即完成了一次中断</p><h2 id="计数器和定时器"><a href="#计数器和定时器" class="headerlink" title="计数器和定时器"></a>计数器和定时器</h2><h3 id="计数原理"><a href="#计数原理" class="headerlink" title="计数原理"></a>计数原理</h3><p>计数器每收到一个脉冲，就会加一，当计数值累计至全为1时（8位255,13位8191,16位65535），再输入一个计数脉冲，计数器就会溢出回零，同时向内核发出中断请求，从而完成计数操作</p><p>计时器和定时器的控制寄存器包括：</p><ul><li>计数初值寄存器<code>TH0/1，TL0/1</code>：我们知道，计数器只有在累计至各位全为1时才会发出中断请求。所以当我们要计数特定值时，我们就需要给计数器一个初始值：全为1时计数 - 我们要计的数，这样当计数器加上我们想要计的值时，他就会刚好溢出并发出中断请求</li><li>模式控制器<code>TMOD</code>：</li></ul><p><img src="/image/$%7Bfiilename%7D/image-20240302210350301.png" alt="image-20240302210350301"></p><ul><li>中断标志寄存器<code>TCON</code>：</li></ul><p><img src="/image/$%7Bfiilename%7D/image-20240302211835416.png" alt="image-20240302211835416"></p><p>在<code>TCON</code>中，与计数器启动有关的位为<code>TR0</code>和<code>TR1</code>，这两位置1时，分别控制计数器0和计数器1的启动</p><h3 id="代码部分-2"><a href="#代码部分-2" class="headerlink" title="代码部分"></a>代码部分</h3><p>计数器&#x2F;定时器的编程方式也较为固定：</p><ol><li>配置工作模式，即给<code>TMOD</code>寄存器赋一个初值来确定模式</li><li>计算计数器初值，将高八位赋给<code>TH0/1</code>，第八位赋给<code>TL0/1</code></li><li>使能定时&#x2F;计数器中断，即<code>ET0/1</code>置1（见上面中断放的那张灰色图）</li><li>打开总中断，即<code>EA=1</code></li><li>启动定时器，即<code>TR0/1=1</code></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitTimer0</span><span class="params">()</span> &#123;</span><br><span class="line"> TMOD = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">//计数50ms，即50000次脉冲</span></span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">ET0 = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一个中断服务函数：</p><ul><li>先初始化计数器，还计那么多数</li><li>再根据题意完成我们要的操作，比如一个定时器最多也就计65.5ms，当我们需要定的时超过这个时，我们就需要设置一个<code>count</code>来记录定时器溢出次数，这样就可以在相应溢出次数时完成我们需要的操作</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">    <span class="comment">//初始化计数器，再计50000次，完成循环</span></span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">count++;</span><br><span class="line">    <span class="comment">//执行我们需要的操作</span></span><br><span class="line"><span class="keyword">if</span> ((count % <span class="number">10</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> L1 = ~L1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">100</span>) &#123;</span><br><span class="line"> L8 = ~L8;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器实现秒表功能"><a href="#定时器实现秒表功能" class="headerlink" title="定时器实现秒表功能"></a>定时器实现秒表功能</h3><p>上面介绍了计数器和定时器最基本的使用方法并简单计时，下面我们来通过更复杂一点的代码并结合之前所学的知识来实现秒表功能</p><p>该功能涉及到内容：</p><ul><li>数码管的动态显示</li><li>独立按键的应用</li><li>定时器</li></ul><p><strong>我们要实现的具体功能如下：</strong></p><p>我们利用数码管设计一个秒表，使其具有清零、暂停、启动功能：</p><ol><li>显示格式为：分（两位）- 秒（两位） - 每0.05s（两位：即满20向前一位秒进1）</li><li>独立按键控制（按键按下即为有效）：<code>S4</code>：暂停&#x2F;启动，<code>S5</code>：清零</li></ol><p><strong>设计思路：</strong></p><ol><li>实现<code>HC138</code>选择函数来选择6（数码管位置）还是7（数码管内容）</li><li>数码管显示函数：通过传入参数位置和内容来使特定一位显示特定内容</li><li>时间显示函数：调用数码管显示函数，利用动态显示来显示每一位该显示的内容</li><li>定时器相关函数：启动函数和中断服务函数</li><li>按键扫描函数：看看<code>S4</code>和<code>S5</code>有没有被按下（做去抖动处理）</li></ol><p><strong>代码实现：</strong></p><p>这里直接贴上全部代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SMG_duanma[<span class="number">18</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>,</span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x80</span>, <span class="number">0xc6</span>, <span class="number">0xc0</span>, <span class="number">0x86</span>, <span class="number">0x8e</span>,</span><br><span class="line"><span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;</span><br><span class="line"><span class="comment">//对应按键定义</span></span><br><span class="line">sbit S4 = P3^<span class="number">3</span>;</span><br><span class="line">sbit S5 = P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> minute = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> second = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> t_50ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> channel)</span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (channel) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xa0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xc0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xe0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数码管</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplaySMG_Bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> value, <span class="type">unsigned</span> <span class="type">char</span> pos)</span> &#123;</span><br><span class="line"> SelectHC138(<span class="number">6</span>);</span><br><span class="line"> P0 = <span class="number">0x01</span> &lt;&lt; pos;</span><br><span class="line"> SelectHC138(<span class="number">7</span>);</span><br><span class="line"> P0 = SMG_duanma[value];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelaySMG</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span> &#123;</span><br><span class="line"> <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayTime</span><span class="params">()</span> &#123;</span><br><span class="line">DisplaySMG_Bit((t_50ms % <span class="number">10</span>), <span class="number">7</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((t_50ms / <span class="number">10</span>), <span class="number">6</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit(<span class="number">16</span>, <span class="number">5</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((second % <span class="number">10</span>), <span class="number">4</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((second / <span class="number">10</span>), <span class="number">3</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit(<span class="number">16</span>, <span class="number">2</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((minute % <span class="number">10</span>), <span class="number">1</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>); </span><br><span class="line">DisplaySMG_Bit((minute / <span class="number">10</span>), <span class="number">0</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器相关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitTimer0</span><span class="params">()</span> &#123;</span><br><span class="line">TMOD = <span class="number">0x01</span>;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">ET0 = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">t_50ms++;</span><br><span class="line"><span class="keyword">if</span> (t_50ms == <span class="number">20</span>) &#123;</span><br><span class="line">second++;</span><br><span class="line">t_50ms = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (second == <span class="number">60</span>) &#123;</span><br><span class="line">minute++;</span><br><span class="line">second = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minute &gt; <span class="number">99</span>) &#123;</span><br><span class="line">minute = <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键扫描</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayK</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//暂停</span></span><br><span class="line"><span class="keyword">if</span> (S4 == <span class="number">0</span>) &#123;</span><br><span class="line"> DelayK(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S4 == <span class="number">0</span>) &#123;</span><br><span class="line">TR0 = ~TR0;</span><br><span class="line"><span class="keyword">while</span> (S4 == <span class="number">0</span>) &#123;</span><br><span class="line"> DisplayTime();</span><br><span class="line">&#125;     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清零</span></span><br><span class="line"><span class="keyword">if</span> (S5 == <span class="number">0</span>) &#123;</span><br><span class="line"> DelayK(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S5 == <span class="number">0</span>) &#123;</span><br><span class="line">minute = <span class="number">0</span>;</span><br><span class="line">second = <span class="number">0</span>;</span><br><span class="line">t_50ms = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S5 == <span class="number">0</span>) &#123;</span><br><span class="line"> DisplayTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">InitTimer0();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ScanKeys();</span><br><span class="line">DisplayTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，通过上面代码，我们就完成了题目中的要求。</p><p>秒表功能将我们很多之前学到的知识结合到了一起，算是一个非常好的练习题，它带我们回顾前面学到的一些功能，很推荐去自己写一写。</p><h2 id="PWM脉宽调制"><a href="#PWM脉宽调制" class="headerlink" title="PWM脉宽调制"></a>PWM脉宽调制</h2><h3 id="调制原理"><a href="#调制原理" class="headerlink" title="调制原理"></a>调制原理</h3><p>PWM脉宽调制即在一个周期内，信号一部分为高电平，一部分为低电平</p><p>比如，当PWM脉宽信号频率为100Hz，占空比为60%时，此时PWM信号周期为0.01s，也就是100ms。那么在这100ms中，我们让前60ms为高电平，后40ms为低电平，就可以实现占空比60%了</p><p>我们通过PWM占空比，可以调节功率，比如控制LED的亮度（由于LED低电平亮，所以占空比越低LED越亮）</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以利用定时器来实现PWM脉宽调制</p><p>比如，我们设定PWM脉宽信号频率为100Hz，占空比可通过按键调节</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pwm_duty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitTimer0</span><span class="params">()</span> &#123;</span><br><span class="line">TMOD = <span class="number">0x01</span>;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">100</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">100</span>) % <span class="number">256</span>;</span><br><span class="line">ET0 = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>; </span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">100</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">100</span>) % <span class="number">256</span>;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= pwm_duty) &#123;</span><br><span class="line">L1 = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line"> L1 = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">100</span>) &#123;</span><br><span class="line"> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，我们就实现了PWM占空比为<code>pwm_duty/100</code>，我们再通过其他函数来改变<code>pwm_duty</code>的值便可以实现要求</p><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h3><p>波特率：串口每秒钟传输的位数（我们用的一般是9600）</p><p>我们通常使用定时器1的工作模式2（8位自动重装）来产生波特率，<code>TL1</code>作为脉冲计数寄存器，<code>TH1</code>作为自动重装寄存器，当计数到最大值溢出时，<code>TH1</code>的值会自动装到<code>TL1</code>中</p><p>所以，当我要产生9600BPS的波特率时</p><ul><li><code>SMOD = 0</code>时，<code>TH1 = TL1 = 0xfd</code></li><li><code>SMOD = 0</code>时，<code>TH1 = TL1 = 0xfa</code></li></ul><p>在串行口中有两个缓冲寄存器<code>SBUF</code>，一个是发送寄存器，一个是接收寄存器。</p><p>串行发送时，CPU向<code>SBUF</code>写入数据，发送完成后标志位<code>TI</code>会置1，这时候需要我们手动让<code>TI = 0</code></p><p>串行接收时，CPU从<code>SBUF</code>接收数据，内核接收到一个完整数据后，会将标志位<code>RI</code>置1，这时候我们从<code>SBUF</code>读取即可</p><p><img src="/image/$%7Bfiilename%7D/image-20240303205647340.png" alt="image-20240303205647340"></p><p>根据上图，我们在<code>Uart初始化函数</code>中，需要让<code>SCON = 0x50</code>。同时因为我们要用到定时器1，我们需要让<code>TMOD = 0x20</code>，并开启定时器1相关使能</p><p>同时由于我们使用的单片机与我们头文件引用的库并不完全相同，我们需要在文件最前面写<code>sfr AXUR = 0x8e</code>来将<code>AXUR</code>定义，并在初始化函数中让<code>AXUR = 0x00</code></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sfr AUXR = <span class="number">0x8e</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> urData = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Uart初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitUart</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//自动重装8位定时器</span></span><br><span class="line">TMOD = <span class="number">0x20</span>;</span><br><span class="line">    </span><br><span class="line">TH1 = <span class="number">0xfd</span>;</span><br><span class="line">TL1 = <span class="number">0xfd</span>;</span><br><span class="line">TR1 =<span class="number">1</span>;</span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">AUXR = <span class="number">0x00</span>;</span><br><span class="line">ES = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">SBUF = dat;</span><br><span class="line"><span class="keyword">while</span> (TI == <span class="number">0</span>);</span><br><span class="line">TI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceUart</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line"> <span class="keyword">if</span> (RI == <span class="number">1</span>) &#123;</span><br><span class="line">RI = <span class="number">0</span>;</span><br><span class="line">urData = SBUF; </span><br><span class="line">SendByte(urData + <span class="number">1</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">InitUart();</span><br><span class="line">SendByte(<span class="number">0x5a</span>);</span><br><span class="line">SendByte(<span class="number">0xa5</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码，我们并可以实现在单片机开机后向CPU发送5a和a5，并在接收到CPU发送的数据后加一再发回去</p><h3 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a>进阶应用</h3><p>那么接下来，我们对串口通信进行更难一点的应用来加强我们的理解</p><p>我们要实现的功能如下：</p><p><img src="/image/$%7Bfiilename%7D/image-20240303210605046.png" alt="image-20240303210605046"></p><p>那么对于略微复杂的问题，我们在敲代码之前一定要先想清楚我们都要干嘛:</p><ul><li>先初始化系统，关掉所有LED，蜂鸣器和继电器</li><li>初始化<code>Uart</code>（用到定时器1），对相关使能以及模式进行赋值</li><li>向上位机发送字符串<code>“Welcome to My System”</code></li><li>接受上位机发送的信号，并据此进行相应控制</li></ul><p>好的，上面就是我对这道题的全部思路，我的实现代码如下（为了体现整体逻辑，就不将代码拆开分功能实现了，直接全贴上来）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sfr AXUR = <span class="number">0x8e</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> channel)</span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (channel) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xa0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对系统进行初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSystem</span><span class="params">()</span> &#123;</span><br><span class="line"> SelectHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line">SelectHC138(<span class="number">4</span>);</span><br><span class="line">P0 = <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口相关</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> command = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitUart</span><span class="params">()</span> &#123;</span><br><span class="line">TMOD = <span class="number">0x20</span>;</span><br><span class="line">TH1 = <span class="number">0xfd</span>;</span><br><span class="line">TL0 = <span class="number">0xfd</span>;</span><br><span class="line">TR1 = <span class="number">1</span>;</span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">AXUR = <span class="number">0x00</span>;</span><br><span class="line">ES = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceUart</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line"><span class="keyword">if</span> (RI == <span class="number">1</span>) &#123;</span><br><span class="line">command = SBUF;</span><br><span class="line">RI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  SBUF = dat;</span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">TI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(*str) &#123;</span><br><span class="line">SendByte(*str++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DoCommand</span><span class="params">()</span> &#123;</span><br><span class="line">SelectHC138(<span class="number">4</span>);  <span class="comment">//也可以不写，系统初始化最后选择的是4</span></span><br><span class="line"> <span class="keyword">if</span> (command != <span class="number">0x00</span>) &#123;</span><br><span class="line"> <span class="keyword">switch</span> (command &amp; <span class="number">0xf0</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xa0</span>:</span><br><span class="line">                <span class="comment">//下面是利用位运算实现的相关控制，其实也可以使用if判断实现</span></span><br><span class="line">P0 = (P0 | <span class="number">0x0f</span>) &amp; (~command | <span class="number">0xf0</span>);</span><br><span class="line"> command = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xb0</span>:</span><br><span class="line">P0 = (P0 | <span class="number">0xf0</span>) &amp; ((~command &lt;&lt; <span class="number">4</span>) | <span class="number">0x0f</span>); </span><br><span class="line">  command = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xc0</span>:</span><br><span class="line">SendString(<span class="string">&quot;The System is Running...\r\n&quot;</span>);</span><br><span class="line">command = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">break</span>;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">InitSystem();</span><br><span class="line">InitUart();</span><br><span class="line">SendString(<span class="string">&quot;Welcome to My System\n&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">DoCommand();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
