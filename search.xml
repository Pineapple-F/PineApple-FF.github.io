<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OO第一单元总结</title>
      <link href="/2024/03/21/oo-Unit1/"/>
      <url>/2024/03/21/oo-Unit1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在三周的磕磕绊绊中，也算是顺利完成了oo第一单元的三次作业。面对久仰大名的oo，虽说的确很累，但也收获良多。</p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>读入一个包含加、减、乘、乘方以及括号（其中括号的深度<strong>至多为 1 层</strong>）的<strong>单变量</strong>表达式，输出<strong>恒等变形展开所有括号后</strong>的表达式。</p><p>需求如下：</p><ol><li>处理括号</li><li>处理指数</li><li>计算加，减，乘</li><li>化简合并得到结果</li></ol><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>对于输入的一个表达式，我主要分为两步进行处理：</p><p>第一步：<strong>解析</strong>表达式，得到后缀表达式</p><p>第二步：<strong>计算</strong>后缀表达式，得到结果</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p>首先我对输入的表达式进行了一波<strong>预处理</strong>，主要就干了两件事：去空格，连续的加减号变成一个符号</p></li><li><p>然后，开始解析表达式，我在课程组在training中提供的<strong>递归下降</strong>算法的代码基础上，根据题目要求做了稍微修改，得到后缀表达式（不得不说，课程组给的代码真是救大命）</p><p>这里要提一句，由于第一次作业经验不足，我将<strong>指数</strong>在解析表达式阶段处理，也就是解析时读到一个^，就将前面的式子乘对应指数遍，比如我读到<code>(x+1)^3</code>，我就会处理成<code>(x+1)*(x+1)*(x+1)</code>，一个^还好，一旦指数嵌套，由于我存的时候没有化简合并，就会有爆时间和爆内存的风险，也是导致了我在第二次作业强测的第二个点挂掉。所以指数处理还是要在第三步计算时实现。</p></li><li><p>现在我们要对上一步得到的后缀表达式进行<strong>计算</strong>来得到最终结果。本次作业主要自己写的也就是这一部分。具体实现方式是我新建了一个Calculate类用于实现计算操作。</p><p>我们可以发现最终得到的结果是一个多项式，而其中每一个单项式都是<code>系数*x^指数</code>的形式（要注意输出时判断一下系数和指数的值看能否省略或化简），那么由于底数都是x，我们就可以用一个<code>HashMap&lt;Integer,BigInteger&gt;</code>来存储多项式，即<code>HashMap&lt;指数，系数&gt;</code>。比如<code>3*x^2+4*x^5</code>我们就可以存成<code>HashMap&lt;(2,3),(5,4)&gt;</code>同时由于指数作为<code>key</code>，我们也可以更容易的实现同类项的合并。</p><p>之后，由于我们是对后缀表达式做处理，所以可以用<code>ArrayList</code>来代表一个<strong>栈</strong>，里面存储多项式.这样在后缀表达式中读到数字或者x，我们就将其存入栈中；读到符号就取栈顶的两个多项式进行对应的加、减、乘的计算得到结果再存入栈中，当处理完后缀表达式后，栈中只剩下一个多项式，就是最终的结果了。</p></li></ol><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="D:\Blogger\hexo-blog\source\image${fiilename}\add2f020de3e7848130a4664f603be7.png" alt="add2f020de3e7848130a4664f603be7"></p><h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><p>由于第一次作业相对比较简单，所以优化方式也不多，在进行同类项的合并之后只需要注意一下将多项式中的首个负项放在最前面即可</p><h3 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>本次作业强测以及互测都没有出现bug，同时在互测中也没有测出别人的bug（满心期待的把别人代码丢到我的评测机里跑，跑了半天也什么bug都没有）</p><p>在本次作业中我也是第一次搭建评测机完成自动化测试，我在往届学长的评测机代码的基础上进行了稍微修改也搞出了一个自己的评测机，还算成就感满满。</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><p>第二次作业我认为是三次作业中最困难的一次，新增功能不少，同时处理指数函数对于刚刚入门oo的我也有不小的难度</p><h3 id="新增需求"><a href="#新增需求" class="headerlink" title="新增需求"></a>新增需求</h3><ol><li>支持处理嵌套多层括号</li><li>新增指数函数因子：<code>exp(因子)^指数</code></li><li>新增自定义函数因子</li></ol><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>整体流程和第一次作业一样，还是先解析得到后缀表达式，再计算后缀表达式并化简合并输出最终结果。</p><ol><li>对于处理嵌套<strong>多层括号</strong>：在第一次作业中的递归下降算法便足以解决这个问题，无需新增代码</li><li>对于<strong>自定义函数</strong>：我在预处理阶段从字符串层面对于自定义函数进行替换</li><li>对于<strong>指数函数因子</strong>：对calculate类进行重构，改变数据结构来存储新的多项式，同时改变加，减，乘的方法。</li></ol><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li><p><strong>自定义函数</strong>处理：我新建了一个<code>SelfDefineFun</code>类用于存放输入的自定义函数。随后在表达式预处理中，我遍历表达式，如果读到f, g, h那么就将找到完整的函数交给<code>SelfDefineFun</code>类处理，并利用在自定义函数类中写的<code>toString</code>方法得到处理之后的字符串。</p><p>这里要注意两个点：</p><p>第一个点是要注意嵌套自定义函数的情况，使用递归处理即可</p><p>第二个点是注意替换x的时候不要把exp中的x也换掉</p></li><li><p><strong>解析</strong>表达式修改：由于本次新增指数函数，所以就在递归下降中加入<code>parseExp</code>方法，位置和解析括号位置相同。</p><p>此外，我对于<code>exp()</code>后面可能存在的指数的处理方法是将指数乘进括号内，比如<code>exp(x)^2</code>就处理成<code>exp(x*2)</code>，这样就可以使我在最终输出前所有的<code>exp()</code>都没有指数，方便我对<code>exp()</code>从字符串层面进行同类项合并</p></li><li><p>重构<strong>计算</strong>类：这个可真是下了大功夫，也是写了很多面对过程编程的代码，本来打算重构的，但是第三次作业刚好用到了一部分，也就没有全改掉</p><p>和上次一样，我发现最后的多项式由相同形式的单项式组成，每个单项式都是<code>系数*x^指数*exp((多项式))</code>，于是我用<code>TreeMap&lt;String, Integer&gt;</code>来存储单项式，<code>TreeMap&lt;TreeMap&lt;String, Integer&gt;, BigInteger&gt;</code>来存储多项式，再和上次一样用一个<code>ArrayList</code>来作为计算的栈存放多项式。</p><p>具体计算就是和上一次作业大致类似，就是需要重新写加、减、乘方法来实现对指数函数的计算与合并</p></li><li><p><strong>输出</strong>：我的<strong>优化</strong>均在输出时实现，也就是在输出时判断指数和系数的值看是否需要输出，以及对exp()内的情况进行判断来确定输出方式</p></li></ol><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><img src="D:\Blogger\hexo-blog\source\image\${fiilename}\65127e2ec3a0bad53c8cb0975cab0ab.png" alt="65127e2ec3a0bad53c8cb0975cab0ab"  /><h3 id="优化方式-1"><a href="#优化方式-1" class="headerlink" title="优化方式"></a>优化方式</h3><p>本次优化还是有很多方面需要考虑的，我做了如下实现：</p><ol><li>第一个负项提到最前面</li><li>对于exp内部相同的进行合并</li><li><code>exp((因子))</code> -&gt; <code>exp(因子)</code></li><li><code>exp((系数*因子))</code>  -&gt; <code>exp(因子)^系数</code></li></ol><p>除了我做的这些优化之外，还有人做到了将exp()内的公因式提取到括号外，以及将一个exp()拆成两个exp()相乘。由于考虑到正确性优先以及实现其他优化对代码改动较多，我没有继续优化。</p><h3 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>很不幸，我的本次作业在强测中挂掉两个点：</p><p>第一个点是因为处理指数函数的方式错误导致面对<code>(((((((((((x^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8</code>这样的数据时出现了<code>MEMORY_LIMIT_EXCEED</code>错误。</p><p>第二个点是由于在优化时我将exp()内的系数提到括号外，但由于我之前所有的exp()都是不带指数的，所以我之前对<code>exp(因子)</code>都是直接采取<code>subString(4, exp.length() - 1)</code>的方法获取exp()内的因子，这也导致了优化后出现指数时获取因子错误。</p><p>在互测中被hack的点和强测的第二个点错误方式一样。</p><p>但同时，我在互测中也成功hack到别人三个错误：</p><ol><li>由于优化时去掉括号错误导致出现<code>exp(-x)</code></li><li>提取公因式时将负数提出到指数位置</li><li>处理自定义函数时在读入其中exp()内的因子出现错误</li></ol><p>前两个点均是通过自己捏数据来hack到的，第三个错误是利用我的评测机跑出来的，自己的评测机第一次在互测中发挥作用，感觉很不错。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><p>第三次作业确实挺简单的，抱着死磕两三天的心态开始第三次作业，结果一个晚上搞完了。虽说轻松却没有了第二次作业的激情，让这周像过博客周一样。</p><h3 id="新增需求-1"><a href="#新增需求-1" class="headerlink" title="新增需求"></a>新增需求</h3><ol><li>自定义函数定义时可以出现之前定义过的<strong>其他自定义函数</strong></li><li>新增<strong>求导因子</strong></li></ol><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><ol><li>对于自定义函数的改变很简单，就是在替换的时候再调用一下就好</li><li>求导因子我是通过化简后对需要求导的多项式的<strong>每个单项式分别进行求导</strong>处理，因为单项式有通项形式，所以实现较为容易</li></ol><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里就说说对求导的处理吧</p><ol><li><p>解析阶段：和exp()一样，我把dx()当做整体存进后缀表达式中，同时dx()里面也是后缀表达式形式</p></li><li><p>计算阶段：求导无非就是对一个表达式也就是一个多项式求导，那么多项式求导就是其中的每个单项式分别求导再相加。</p><p>我们知道单项式的通项形式为<code>系数*x^指数*exp((多项式))</code>，那么这个东西求导就是前导后不导加后导前不导，也就是<code>dx(系数*x^指数*exp((多项式)))</code>等于<code>系数*dx(x^指数)*exp((多项式)) + 系数*x^指数*dx(exp((多项式)))  </code>而对于幂函数和指数函数求导又有各自的法则，就很容易处理了。</p></li></ol><h3 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h3><p><img src="D:\Blogger\hexo-blog\source\image${fiilename}\b7e920fa1a46c6f9676b0d36e949387.png" alt="b7e920fa1a46c6f9676b0d36e949387"></p><h3 id="优化方式-2"><a href="#优化方式-2" class="headerlink" title="优化方式"></a>优化方式</h3><p>由于第三次作业和第二次的输出形式可以说是一模一样，我在第二次的优化方案上并没有新增其他优化</p><h3 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h3><p>和第一周一样，我在强测和互测中均没有出现错误，同时互测房内也都没有出现bug</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>​持续三周的第一单元这么快就过去了，现在想想，前两周冥思苦想无从下手的样子仿佛还在眼前。oo不仅让我学到了面向对象编程的思想，让我的代码思路更清楚，一切为对象服务、接口封装，一段码该干嘛就干嘛，不用乱加其他功能，同时也提升了我对较大规模代码的整体设计能力以及debug能力。在之前我编写代码时可能想一点写一点，但现在，我会拿出一张纸，好好构思好好设计，思考每个类的功能以及他和其他类的关系，争取让我的设计更优雅，我的代码更清晰。</p><p>​同时，在第三周和第四周任务量很少的时候，我也老会觉得空唠唠的，可能甚至习惯了前两周的高强度oo时光了吧。所以，已经期待着下一单元了，继续探索，继续战斗，继续痛苦并快乐着！</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><p>对于第一单元修改的建议，我个人看法有以下两个方面：</p><ol><li>感觉可以修改一下cost机制，有时候很简单的数据过不了cost限制，一些相对复杂的数据又不会被限制（虽然我没仔细研究过cost机制，但在hack别人的时候是这种感受）</li><li>可以调整一下第三单元难度，从第二单元到第三单元落差有点太大了，感觉可以增加一些难度</li></ol><p>这就是我的第一单元总结了，oo第一单元完结，撒花！</p>]]></content>
      
      
      <categories>
          
          <category> oo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-lab0</title>
      <link href="/2024/03/14/OS-lab0/"/>
      <url>/2024/03/14/OS-lab0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking-0-1-：Git的状态转换"><a href="#Thinking-0-1-：Git的状态转换" class="headerlink" title="Thinking 0.1 ：Git的状态转换"></a>Thinking 0.1 ：Git的状态转换</h3><p>思考下列有关 Git 的问题：</p><ul><li>在前述已初始化的 <code>~/learnGit</code> 目录下，创建一个名为 <code>README.txt</code> 的文件。执 行命令 <code>git status &gt; Untracked.txt</code>（其中的 &gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。 </li><li>在 <code>README.txt</code> 文件中添加任意文件内容，然后使用 <code>add</code> 命令，再执行命令 <code>git status &gt; Stage.txt</code>。</li><li>提交 <code>README.txt</code>，并在提交说明里写入自己的学号。</li><li>执行命令 <code>cat Untracked.txt</code> 和 <code>cat Stage.txt</code>，对比两次运行的结果，体会 README.txt 两次所处位置的不同。</li><li>修改 <code>README.txt</code> 文件，再执行命令 <code>git status &gt; Modified.txt</code>。</li><li>执行命令 <code>cat Modified.txt</code>，观察其结果和第一次执行 <code>add</code> 命令之前的 <code>status</code> 是 否一样，并思考原因。</li></ul><p>答：</p><ul><li><p>本思考题主要探讨的问题为Git中的四种状态转换关系，如下图</p><img src="/image/${fiilename}/image-20240311104956433.png" alt="image-20240311104956433" style="zoom: 80%;" /></li><li><p>第一次查看状态时重定向到<code>Untracked.txt</code>中的输出为：</p><img src="/image/${fiilename}/image-20240311104546116.png" alt="image-20240311104546116" style="zoom: 50%;" /><p>说明此时文件处于<strong>未追踪状态</strong>（Untracked)</p></li><li><p>使用<code>add</code>命令后，第二次查看状态时的状态为：</p><img src="/image/${fiilename}/image-20240311104709625.png" alt="image-20240311104709625" style="zoom: 50%;" /><p>此时经过<code>git add</code>命令后，<code>README.txt</code>和<code>Untracked.txt</code>被添加到<strong>暂存区</strong>(Staged)</p></li><li><p>最后，提交并修改后再次查看状态：</p><img src="/image/${fiilename}/image-20240311110207393.png" alt="image-20240311110207393" style="zoom: 50%;" /><p>文件提交后处于<strong>Unmodified</strong>区，再对其进行修改后文件位于<strong>modified</strong>区</p></li><li><p>所以，对于思考题中的问题：<code>观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。</code></p><p>答案是两次的<code>status</code>是不一样的，根据我上面的分析，第一次执行<code>add</code>命令之前的<code>status</code>是<code>Untracked</code>，而最后的<code>status</code>为<code>modified</code>，所以状态不同</p></li></ul><h3 id="Thinking-0-2-：Git状态转换命令"><a href="#Thinking-0-2-：Git状态转换命令" class="headerlink" title="Thinking 0.2 ：Git状态转换命令"></a>Thinking 0.2 ：Git状态转换命令</h3><p>仔细看看下图，思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？</p><img src="/image/${fiilename}/image-20240311104956433.png" alt="image-20240311104956433" style="zoom: 80%;" /><ul><li>还是上面思考题最前面放的那张图，本思考题要我们思考图中箭头对应的指令是什么</li><li><code>add the file</code>：对应<code>git add</code>指令</li><li><code>stage the file</code> ：同样对应 <code>git add</code> 指令</li><li><code>commit</code>： 对应 <code>git commit</code> 指令</li></ul><h3 id="Thinking-0-3-：Git文件恢复"><a href="#Thinking-0-3-：Git文件恢复" class="headerlink" title="Thinking 0.3 ：Git文件恢复"></a>Thinking 0.3 ：Git文件恢复</h3><p>思考下列问题： </p><ol><li>代码文件 <code>print.c</code> 被错误删除时，应当使用什么命令将其恢复？ </li><li>代码文件 <code>print.c</code> 被错误删除后，执行了 <code>git rm print.c</code> 命令，此时应当 使用什么命令将其恢复？</li><li>无关文件 <code>hello.txt</code> 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</li></ol><p>答：</p><ol><li>执行 <code>git checkout -- printf.c</code> 指令，</li><li>先执行 <code>git reset HEAD printf.c</code> 指令，然后执行 <code>git checkout -- printf.c</code> 指令</li><li>执行 <code>git rm --cached hello.txt</code> 指令</li></ol><h3 id="Thinking-0-4：Git版本回退"><a href="#Thinking-0-4：Git版本回退" class="headerlink" title="Thinking 0.4：Git版本回退"></a>Thinking 0.4：Git版本回退</h3><p>思考下列有关 Git 的问题：</p><ul><li>找到在 <code>/home/22xxxxxx/learnGit</code> 下刚刚创建的 README.txt 文件，若不存 在则新建该文件。</li><li>在文件里加入 <code>Testing 1</code>，git add，<code>git commit</code>，提交说明记为 1。 • 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</li><li>使用 <code>git log</code> 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值a。</li><li>进行版本回退。执行命令 <code>git reset --hard HEAD^</code> 后，再执行 <code>git log</code>，观 察其变化。</li><li>找到提交说明为 1 的哈希值，执行命令 <code>git reset --hard &lt;hash&gt;</code>  后，再执行 <code>git log</code>，观察其变化。</li><li>现在已经回到了旧版本，为了再次回到新版本，执行 <code>git reset --hard &lt;hash&gt;</code>   ，再执行 <code>git log</code>，观察其变化。</li></ul><p>答：</p><ul><li><p>按照题目中前三条操作后：</p><img src="/image/${fiilename}/image-20240311143945383.png" alt="image-20240311143945383" style="zoom: 50%;" /><p>我们可以发现已经有三次提交，提交3的哈希值a为<code>13e87e5473698331de9e0c5e5b00c2ce222cc5e1</code></p></li><li><p>执行 <code>git reset --hard HEAD^</code>进行版本回退后，再执行<code>git log</code>我们发现提交日志中只剩下两次提交，如下图：</p><img src="/image/${fiilename}/image-20240311144349852.png" alt="image-20240311144349852" style="zoom:50%;" /><p>提交1的哈希值为<code>e283774abeee6b0a5d4cb2a4d1174107938254be</code></p></li><li><p>再执行<code>git reset --hard e283774abeee6b0a5d4cb2a4d1174107938254be</code>，版本再次回退，提交日志中只剩下提交1的日志</p></li><li><p>执行完上述操作以及观察到对应现象后，我认为<code>git reset</code> 指令能让我们通过不同提交对应的哈希值，移动 <code>HEAD</code> 回退到任意的版本，更新暂存区和版本库的当前版本，从而实现版本回退。但在参数为 <code>--hard</code> 的情况下会同时覆盖掉工作目录下的文件，相当于把原本的工作目录使用回退版本库中的内容也全部覆盖掉；所以若工作目录下的文件还未提交，则 <code>Git</code> 仍会覆盖它从而导致无法恢复，有一定风险，所以也要慎用。</p></li></ul><h3 id="Thinking-0-5-：echo"><a href="#Thinking-0-5-：echo" class="headerlink" title="Thinking 0.5 ：echo"></a>Thinking 0.5 ：echo</h3><p>执行如下命令, 并查看结果：</p><ul><li><code>echo first</code></li><li><code>echo second &gt; output.txt</code></li><li><code>echo third &gt; output.txt</code></li><li><code>echo forth &gt;&gt; output.txt</code></li></ul><p>答：</p><ul><li><p>执行完上面四条操作后，我们在终端看到了第一条命令执行输出的<code>first</code>，再查看<code>output.txt</code>中内容：</p><img src="/image/${fiilename}/image-20240311150737313.png" alt="image-20240311150737313" style="zoom: 80%;" /></li><li><p>我们发现只有<code>third</code>和<code>forth</code>，并没有<code>second</code>。原因是第三条命令<code>echo third &gt; output.txt</code>没有使用<code>&gt;&gt;</code>，所以将第二条命令在<code>output.txt</code>中的输出覆盖掉，而第四条使用了<code>&gt;&gt;</code>，将<code>forth</code>接在原来<code>output.txt</code>文件的末尾</p></li></ul><h3 id="Thinking-0-6-："><a href="#Thinking-0-6-：" class="headerlink" title="Thinking 0.6 ："></a>Thinking 0.6 ：</h3><p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test）， 将创建该文件的命令序列保存在 <code>command</code> 文件中，并将 <code>test</code> 文件作为批处理文件运行，将 运行结果输出至 <code>result</code> 文件中。给出 <code>command</code> 文件和 <code>result</code> 文件的内容，并对最后的结 果进行解释说明（可以从 <code>test</code> 文件的内容入手）. 具体实现的过程中思考下列问题: </p><ul><li>echo echo Shell Start 与 echo <code>echo Shell Start</code> 效果是否有区别; </li><li>echo echo $c&gt;file1 与 echo <code>echo $c&gt;file1</code> 效果是否有区别.</li></ul><img src="/image/${fiilename}/image-20240314141116512.png" alt="image-20240314141116512" style="zoom:50%;" /><p>答：</p><ul><li><p>command中内容：</p><img src="/image/${fiilename}/image-20240314143506189.png" alt="image-20240314143506189" style="zoom: 60%;" /></li><li><p>result中内容：</p><img src="/image/${fiilename}/image-20240314143621967.png" alt="image-20240314143621967" style="zoom: 80%;" /></li><li><p>问题思考：</p><ol><li>echo echo Shell Start 与 echo <code>echo Shell Start</code>效果无区别，均为输出echo Shell Start</li><li>echo echo $c&gt;file1 与 echo <code>echo \$c&gt;file1</code>效果有区别，在echo后面出现单引号时，会将单引号包裹的整体来输出</li></ol></li></ul><h2 id="二、难点分析"><a href="#二、难点分析" class="headerlink" title="二、难点分析"></a>二、难点分析</h2><h3 id="gcc相关"><a href="#gcc相关" class="headerlink" title="gcc相关"></a>gcc相关</h3><p>之前我一直在使用各种ide一键即可编译运行.c文件，但在接触操作系统之后，对.c文件的预处理，编译，汇编，链接要靠命令行来完成，也是让刚入门的我感觉到很不习惯，下面列出一些<code>gcc</code>的常用命令，也方便我自己之后忘记时查看</p><ul><li><p><code>gcc -E hello.c &gt; 1.txt</code>：只激活预处理，不生成文件（预处理一个最简单的输出hello world也会处理成几百行的代码）</p></li><li><p><code>gcc -S hello.c</code>：进行预处理，汇编操作，生成汇编文件</p></li><li><p><code>gcc -c hello.c</code>：生成<code>hello.o</code>文件，对文件进行了预处理，编译，汇编的工作</p></li><li><p><code>gcc -o hello hello.c</code>  <code>gcc -o hello hello.o</code>：进行预处理，编译，汇编，链接的工作，生成可执行文件<code>hello</code>，执行命令<code>./hello</code>即可执行</p></li><li><p><code>gcc -I ../include hello.c</code>：如果<code>hello.c</code>中引用头文件，需要使用<code>-I</code>操作</p></li></ul><h3 id="bash脚本编写"><a href="#bash脚本编写" class="headerlink" title="bash脚本编写"></a>bash脚本编写</h3><p>bash脚本是lab0的一个重点，在课上以及课下实验中均出现了编写bash脚本的题目，大致的编写样例如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bin/bash</span></span><br><span class="line"><span class="comment">#首行用于保证直接执行我们的脚本时使用 bash 作为解释器，从第二行开始行首为#代表注释</span></span><br><span class="line"><span class="comment">#bash脚本内部其实就是linux命令行的顺序执行，基础命令在预习博客中，这里不介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bash中传递参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> no parameter</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$#</span> -eq 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> one parameter : <span class="variable">$1</span></span><br><span class="line"><span class="keyword">elif</span> [<span class="variable">$#</span> -eq 2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> two parameters : <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> many patameters : $*</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#上面代码中$#代表传递的参数个数，$*用一个字符串显示传递的全部参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#while语句</span></span><br><span class="line">n=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$n</span> -le 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$n</span></span><br><span class="line"><span class="built_in">let</span> n=n+1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h3><p>在课下实验的第四题中，编写两个Makefile卡了我很长时间，最后看往年博客才彻底搞明白</p><p>Makefile的基本格式如下</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: dependencies</span></span><br><span class="line">command 1</span><br><span class="line">command 2</span><br><span class="line">...</span><br><span class="line">command n</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>target</code>可以理解为指令名字，比如<code>target</code>是<code>clean</code>，那么执行<code>make clean</code>就是执行<code>Makefile</code>中<code>clean：</code>的命令，如果只有<code>make</code>时，默认执行第一个<code>target</code></li><li><code>dependecies</code>是<code>target</code>所依赖的文件或其他<code>target</code></li><li><code>command</code>就是要执行的命令，这里要注意，虽然这里可以写很多命令，但是每条命令都是独立的，比如我的命令需要完成：打开<code>code</code>文件夹并在<code>code</code>文件夹里面再<code>make</code>。那么我需要在一条命令中写<code>cd code &amp;&amp; make</code>而不能拆成两条（这个点卡我好久）</li></ul><h3 id="Linux进阶操作"><a href="#Linux进阶操作" class="headerlink" title="Linux进阶操作"></a>Linux进阶操作</h3><p>在lab0的课上课下实验中，也遇到了一些在os预习教程中没有见过的Linux操作，比如grep, sed, awk等文件处理操作，在刚刚使用时也是有不小的难度，具体使用细节可以在指导书中查看。</p><h2 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h2><p>总的来说，lab0的难度并不大，对我个人而言，难点在于对新工具的适应。比如，我觉得在bash脚本中对变量赋值本该是一件很简单的事，在课上extra中却一直毫无头绪；此外，对于awk等新操作的运用更是极其不熟练，只会一点最基本的操作，希望在之后的学习中可以慢慢用熟。</p><p>不过，对于刚刚接触操作系统，刚刚基础Linux命令的我来说，一切东西都是很新奇，实现很多新的操作也觉得很好玩，希望在之后的实验中也可以一直保持这样的心态，保持好奇，继续探索操作系统的世界。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS预习</title>
      <link href="/2024/02/25/OS%E9%A2%84%E4%B9%A0/"/>
      <url>/2024/02/25/OS%E9%A2%84%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul><li><p><strong>cd</strong></p><p>用法：<code>cd 目录</code></p><p>作用：切换到该目录（类似于打开文件夹）</p><p><code>cd /</code>：&#x2F; 代表根目录，即Linux文件系统的最顶层<br><code>cd ~</code>：~当前用户主目录，对于一般用户，主目录是<code>/home/用户名</code>；如果当前用户是系统管理员(root)用户，主目录是<code>/root</code><br><code>cd /etc/test</code>：切换到<code>etc</code>目录下的<code>test</code>目录（可以理解为打开<code>test</code>文件夹）</p><p><code>cd test</code>：cd命令支持相对路径，如果系统在<code>etc</code>目录，可以输入<code>cd test</code>直接访问<code>test</code>目录</p><p><code>cd .</code>：<code>.</code>表示当前目录<br><code>cd ..</code>：<code>..</code>表示上一级目录<br><code>cd -</code>：<code>-</code>表示上一次访问的目录</p></li><li><p><strong>ls</strong></p><p>用法：<code>ls [选项] [目录]</code> （<code>[]</code>代表可有可无）</p><p>作用：列出目录中的文件</p><p>常用选项：</p><p>​<code>-a</code>：显示隐藏的文件（文件名以 <code>.</code> 开头的文件）</p><p>​<code>-l</code>：每行只列出一个文件</p></li><li><p><strong>mkdir</strong></p><p>用法：<code>mkdir 目录</code></p><p>作用：创建一个新目录</p></li><li><p><strong>pwd</strong></p><p>用法：<code>pwd [选项]</code></p><p>作用：输出当前目录的绝对路径</p></li><li><p><strong>rmdir</strong></p><p>用法：<code>rmdir [选项] 目录</code></p><p>作用：删除一个空的目录。注意：只能是空目录</p></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件操作的对象是几乎所有文件，也包含目录</p><ul><li><p><strong>touch</strong></p><p>用法：<code>touch [选项] 文件名</code></p><p>作用：当文件不存在时创建新文件，当文件存在时更新文件的时间戳</p><p>注意：不能用<code>touch</code>新建目录，要使用<code>mkdir</code></p></li><li><p><strong>rm</strong></p><p>用法：<code>rm [选项] 文件</code></p><p>作用：删除文件</p><p>常用选项：</p><p>​<code>-r</code>：递归删除目录及其内容，删除非空目录必须有此选项，否则无法删除</p><p>​<code>-f</code>： 强制删除，不提示用户确认，忽略不存在的目录</p><p>​<code>-i</code>： 逐一提示用户确认每个将要被删除的文件</p><p>注意：<code>rm -rf</code>一定慎用，全删了，非必要不使用</p></li><li><p><strong>cp</strong></p><p>用法：<code>cp [选项] 源文件 目标路径</code></p><p>作用：将源文件（或目录）复制到目标路径对应的文件或目录</p><p>常用选项：</p><p>​<code>-r</code>：递归移动目录及其子目录内的所有内容</p></li><li><p><strong>mv</strong></p><p>用法：<code>mv [选项] 源文件 目标路径</code></p><p>作用：类似于剪切，将源文件移动至目标位置</p><p>常用选项：</p><p>​<code>-r</code>：递归移动目录及其子目录内的所有内容</p><p><code>mv</code>也可以用来重命名文件比如<code>mv test.txt test2.txt</code>就可以实现对<code>test.txt</code>的重命名</p></li><li><p><strong>diff</strong></p><p>用法：<code>diff [选项] 文件1 文件2</code></p><p>作用：比较两个纯文本文件的差异</p><p>常用选项：</p><p>​<code>-b</code>：不检查空白字符的不同</p><p>​<code>-B</code>：不检查空行</p><p>​<code>-q</code>：仅显示有无差异，不显示详细信息</p></li><li><p><strong>vim</strong></p><p>Vim是Linux系统下的一款开源编辑器，编辑效率很高，下面介绍Vim的基本输入操作</p><p>用法：</p><ol><li><code>vim 文件名</code></li><li>按<code>I</code>进入插入模式，可以开始输入文本内容</li><li>完成文件修改后，按<code>Esc</code>回到命令模式，再按<code>Shift + ;</code>进入底线命令模式，可以看到最后一行出现冒号。输入<code>w</code>并按回车可以保存文件，输入<code>q</code>并按回车可以关闭文件，也可以合并输入<code>wq</code>即可保存并关闭文件</li></ol></li></ul><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><ul><li><p><strong>find</strong></p><p>用法：<code>find [路径] 选项</code></p><p>作用：在给定路径下递归地查找文件，输出符合要求的文件的路径。如果没有给定路径，则在当前目录下查找。</p><p>常用选项： </p><p>​<code>-name 文件名</code> ：指定需要查找的文件名。</p><p>例如在当前目录下查找所有名为<code>test.c</code>文件的操作为<code>find -name test.c</code></p></li><li><p><strong>grep</strong></p><p>用法：<code>grep [选项] PATTERN FILE</code>（PATTERN是匹配字符串，FILE是文件或目录的路径） </p><p>作用：输出匹配字符串PATTERN的文件和相关的行</p><p>常用选项：</p><p>​<code>-a</code>：不忽略二进制数据进行搜索</p><p>​<code>-i</code>：忽略大小写差异</p><p>​<code>-r</code>：从目录中递归查找</p><p>​<code>-n</code>：显示行号</p></li><li><p><strong>tree</strong></p><p>用法：<code>tree [选项] [目录名]</code></p><p>作用：高级版的<code>ls</code>，输出目录下的文件树</p><p>常用选项：</p><p>​<code>-a</code>：列出全部文件（包含隐藏文件）</p><p>​<code>-d</code>：只列出目录</p></li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li><p><strong>man</strong></p><p>用法：<code>man [选项] 命令</code> 阅读完毕后按<code>Q</code>退出</p><p>作用：查看该命令的详细说明手册</p></li><li><p><strong>echo</strong></p><p>用法：<code>echo 要输出内容</code></p><p>作用：直接在终端输出内容</p></li></ul><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li><code>Ctrl + C</code>：终止当前程序执行。注意：在终端复制时就老老实实用右键复制，以免误杀进程。</li><li><code>Ctrl + Z</code>：挂起当前程序，暂停，放到后台<code>Ctrl + Z</code>挂起程序后会显示该程序挂起编号，若想要恢复该程序可以使用 <code>fg [job_spec]</code>即可，<code>job_spec</code> 即为挂起编号，不输入时默认为最近挂起进程。</li><li><code>Ctrl + D</code>：终止输入，在标准输入中输入<code>Ctrl+D</code>也意味着输入了一个 EOF。</li><li><code>Ctrl + L</code>：清屏，相当于命令<code>clear</code>。</li><li><code>方向键 上 下</code>：切换最近使用过的命令。</li></ul><h1 id="相关实用工具"><a href="#相关实用工具" class="headerlink" title="相关实用工具"></a>相关实用工具</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC包含了著名的 C 语言编译器 gcc</p><p>用法：<code>gcc [选项] 源代码文件</code></p><p>作用：编译该文件</p><p>我们可以先输入<code>gcc hello.c</code>编译<code>hello.c</code>文件并在目录下出现<code>a.out</code>文件，我们再通过命令<code>./a.out</code>执行<code>a.out</code>文件获得输出（注意：一定要有<code>./</code>）</p><h2 id="构建并编译运行一个-c文件"><a href="#构建并编译运行一个-c文件" class="headerlink" title="构建并编译运行一个.c文件"></a>构建并编译运行一个.c文件</h2><ol><li><code>cd 目标目录</code>：决定一个存.c文件的位置，打开该目录</li><li><code>touch 名字.c</code>：新建一个.c文件</li><li><code>vim 名字.c</code>：编辑.c文件（相关vim操作见上）</li><li><code>gcc -o &quot;可执行文件名字&quot; 名字.c</code>：编译.c文件，并给生成的可执行文件起个名字</li><li><code>./可执行文件名字 &lt; in.txt &gt; out.txt</code>：执行可执行文件，并利用重定向获取输入和输出（<code>in.txt</code>需要提前建好。<code>out.txt</code>如果原来没有，会自动生成，有了会覆盖掉原来的）</li></ol><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git-中文件的四种储存状态"><a href="#Git-中文件的四种储存状态" class="headerlink" title="Git 中文件的四种储存状态"></a>Git 中文件的四种储存状态</h2><p>一个文件，在 Git 目录中有以下四种状态：</p><ul><li>未跟踪（Untracked）：一个文件在储存库的版本信息中没有被记录过。比如在储存库中新建了一个文件，这个文件现在就是未跟踪的状态；在一个非空目录下使用 <code>git init</code> 来初始化一个空储存库，此时这个目录下的所有文件都处于未跟踪的状态。</li><li>未修改（Unmodified）：一个文件在跟踪之后一直没有改动过，或者改动已经被提交（即工作区的内容和储存库中的内容相同），则处于未修改状态。当我们修改这个文件时，则会使这个文件变成已修改状态。</li><li>已修改（Modified）：一个文件已经被修改（即工作区的内容和储存库中的内容不同），但还没有加入（<code>git add</code>) 到暂存区中。</li><li>已暂存（Staged）：一个文件已被加入暂存区。加入暂存区意味着将一个已修改的文件加入下次提交（<code>git commit</code>）需要存入储存库的文件清单中。</li></ul><p><img src="/image/$%7Bfiilename%7D/image-20240225232606403.png" alt="image-20240225232606403"></p><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><ul><li><p><code>git init</code>：把当前目录变成一个空的 Git 仓库，这样就可以对当前目录下的内容进行版本管理了。</p></li><li><p><code>git clone</code>：“克隆”一个已有的储存库到当前目录下。通常我们会从一个互联网地址（即 URL，统一资源定位符）进行克隆，所以一般这种操作可以理解为“下载”。</p></li><li><p><code>git status</code>：查看当前分支的状态，以及当前工作区的变动和暂存区的内容，便于我们对工作区的概况进行掌握。</p></li><li><p><code>git add</code>：把一个新文件或者已经修改过的文件加入暂存区中。在你完成一部分实验内容之后，可以使用<code>git add .</code> 将所有修改加入暂存区，也可以使用 <code>git add &lt;filename&gt;</code> 来将指定的文件加入暂存区。</p></li><li><p><code>git restore</code>：我们在修改一个文件之后，可能想要放弃这个修改。当这个文件还没有通过 <code>git add</code> 加入暂存区时，我们可以使用 <code>git restore &lt;filename&gt;</code> 来撤销对这个文件的修改，使其退回到上一个 commit 的状态。如果这个文件已经加入了暂存区，我们可以通过 <code>git restore --staged &lt;filename&gt;</code> 来取消暂存。</p></li><li><p><code>git checkout</code>：这个命令涉及到分支的知识，使用 <code>git checkout lab&lt;x&gt;</code> 可以切换到相应的分支。注意，在切换时，需要保证目前所有文件的状态均为“未修改”（没有修改过，或者已经提交）。</p></li><li><p><code>git commit</code>：使用 <code>git commit -m &lt;message&gt;</code> 这个命令将暂存区的修改提交到储存库中。当 message 参数有空格时需要把 message 用引号括起来。在提交时，要求给出一段说明性文字。这段文字可以任意填写，但建议按照提交内容填写，以保证多人协作时的可读性。</p></li><li><p><code>git push</code>：将本地的 commit 推送到一个远程仓库。</p></li><li><p><code>git pull</code>：将远程新建的分支下载到本地，并且将远端的更改合并到当前的分支。在利用评测机进行实验分支的初始化之后，可以在开发机中使用这个命令来将新的分支下载到本地。</p><p><img src="/image/$%7Bfiilename%7D/image-20240225232151061.png" alt="image-20240225232151061"></p></li></ul><p>​<img src="/image/$%7Bfiilename%7D/image-20240225232215486.png" alt="image-20240225232215486"></p><p>在这里贴一张gitlab上关于git操作的说明，感觉还较为全面</p><p>常用操作就是：</p><ol><li><p>先<code>git clone 上传目标库的ssh</code></p></li><li><p>将想要上传的文件拖进<code>git clone</code>出的文件夹中</p></li><li><p><code>git add .</code></p></li><li><p><code>git commit -m &quot;提交说明&quot;</code></p></li><li><p><code>git push</code></p><p>这样就可以将我们要上传的文件成功上传到库中了</p></li></ol><p><img src="/image/$%7Bfiilename%7D/fda83e04fcb352a17c3fc3a3295f7d4.png" alt="fda83e04fcb352a17c3fc3a3295f7d4"></p><h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><h2 id="shell脚本执行"><a href="#shell脚本执行" class="headerlink" title="shell脚本执行"></a>shell脚本执行</h2><p>Shell 脚本执行时，如果没有权限，我们可以使用下面的命令手动添加“执行”权限。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">chmod +x 文件名</span><br></pre></td></tr></table></figure><h2 id="Bash-Shell-语法基础"><a href="#Bash-Shell-语法基础" class="headerlink" title="Bash Shell 语法基础"></a>Bash Shell 语法基础</h2><p>首先用 <code>touch</code> 命令创建一个新文件 <code>hello.sh</code>，使用 Vim 输入以下内容：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#My first Shell script!</span><br><span class="line"><span class="built_in">echo</span> &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure><p>第一行：指定脚本的默认运行程序（即解释器）。在这里指定为 bash，这是我们最常使用的脚本运行程序。</p><blockquote><p>其中，<code>#!</code> 出现在脚本文件的第一行的前两个字符，被称为 Shebang。当文件中存在 Shebang 的情况下，程序加载器会分析 Shebang 后面的内容，并且将这些内容作为脚本文件的解释器。</p></blockquote><p>第二行：注释。注释以 <code>#</code> 开头。</p><p>第三行：输出。将 <code>echo</code> 命令后面的字符串输出。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义方式为：<code>var_name=value</code>（注意：&#x3D; 两边<strong>不允许有空格</strong>）</p><p> 使用<code>$var_name</code> 可以获取变量的值。在使用时，建议在变量名的两端加一个花括号（形如 <code>$&#123;var_name&#125;</code>），以帮助解释器识别变量的边界，避免歧义。</p><p>例如：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">str=&quot;Hello, world!&quot;</span><br><span class="line"><span class="built_in">echo</span> $str</span><br></pre></td></tr></table></figure><h3 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h3><p>我们将<code>hello.sh</code>的内容修改为：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">str=&quot;Hello, $<span class="number">1</span> and $<span class="number">2</span>!&quot;</span><br><span class="line"><span class="built_in">echo</span> $str</span><br></pre></td></tr></table></figure><p>再输入<code>$ ./hello.sh world OS</code>我们可以得到<code>Hello, world and OS!</code>即用执行命令中的<code>world</code>和<code>OS</code>替代脚本中的<code>$1</code>和<code>$2</code></p><p>如果命令中的参数不够，则不输出脚本中多出来的脚本参数；</p><p>除了 <code>$1</code>、<code>$2</code> ，还有一些其他的特殊变量：</p><ul><li><code>$#</code> ：传递的参数个数；</li><li><code>$*</code>：一个字符串，内容是传递的全部参数。</li></ul><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><ul><li><p><strong>if 语句</strong></p><p><code>if</code> 语句块的格式如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line">then</span><br><span class="line">    command11</span><br><span class="line">    command12</span><br><span class="line">    ......</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    command21</span><br><span class="line">    command22</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command31</span><br><span class="line">    command32</span><br><span class="line">    ......</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中，<code>fi</code> 是“if”的倒写，代表 <code>if</code> 语句块的结束；<code>elif</code> 意为“else if”。<code>elif</code> 和 <code>else</code> 可以按需省略。</p><p>下面举例说明：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">if</span> (( $<span class="number">1</span> &gt; $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first &gt; second&quot;</span><br><span class="line">elif (( $<span class="number">1</span> &lt; $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first &lt; second&quot;</span><br><span class="line">elif (( $<span class="number">1</span> == $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first == second&quot;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> &quot;I don&#x27;t know...&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中 <code>(())</code> 是用于比较<strong>整数</strong>之间大小的表达方式。传入字符串或浮点数，则是未定义的行为。</p></li><li><p><strong>while语句</strong></p><p><code>while</code> 语句块的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>其中 <code>done</code> 表示“do”语句块的结束。下面举例说明。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="built_in">mkdir</span> files</span><br><span class="line"><span class="built_in">cd</span> files</span><br><span class="line">i=<span class="number">1</span></span><br><span class="line">while (($i &lt;= $<span class="number">1</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        touch &quot;file$i.txt&quot;</span><br><span class="line">        let i=i+<span class="number">1</span> # or i=$((i+<span class="number">1</span>))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这里，<code>let</code> 是为变量赋值的命令，与之等价地，也可以使用 <code>i=$((i+1))</code>。</p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Shell 脚本也支持<strong>函数</strong>。函数的定义方式如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">function fun_name() &#123;</span><br><span class="line">    body...</span><br><span class="line">    return int_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>function</code> 和 <code>()</code> 可以省略其中一个。其中返回语句是可选的，函数可以不返回值。<code>int_value</code> 是一个0 - 255之间的整数，返回其他值是未定义的行为，一般会返回一个错误的结果。</p><p>函数的调用方法如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">fun_name param1 param2 ... paramN</span><br></pre></td></tr></table></figure><p>其中第 N 个参数在函数体内使用 <code>$N</code> 来获取，且不需要在函数定义开头声明。值得注意的是，当 N&gt;&#x3D;10 时，需要用 <code>$&#123;N&#125;</code> 来获取参数，否则 <code>$</code> 只会带第一位数字。如果函数有返回值，则在函数调用的后面需要使用 <code>$?</code> 获取返回值。例子如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">function fun1() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;Hello, world!&quot;</span><br><span class="line">&#125;</span><br><span class="line">function fun2() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;I&#x27;ve got &quot;$<span class="number">1</span>&quot; and &quot;$<span class="number">2</span>&quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">function fun3() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;I&#x27;m computing first + second!&quot;</span><br><span class="line">        return $(($<span class="number">1</span> + $<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line">fun1</span><br><span class="line">fun2 <span class="number">2</span> <span class="number">3</span></span><br><span class="line">fun3 <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> &quot;The sum is &quot;$?&quot;.&quot;</span><br></pre></td></tr></table></figure><p>其中，<code>$(($1 + $2))</code> 的意思是先计算 <code>$1 + $2</code> 的值。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机——蓝桥杯备赛</title>
      <link href="/2024/02/23/%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/"/>
      <url>/2024/02/23/%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>蓝桥杯比赛指定单片机跟51单片机差不多，可以通过淘宝国信长天购买。</p><p>本次学习跟着<a href="https://www.bilibili.com/video/BV1Bt41187hw/?vd_source=59e4e13f0e1002ef3a96e7a6170a57aa">b站小蜜蜂老师的视频</a></p><p>使用的相关软件为 <code>keil4</code> 和 <code>STC-ISP</code></p><h1 id="相关软件使用"><a href="#相关软件使用" class="headerlink" title="相关软件使用"></a>相关软件使用</h1><p><code>keil4</code>作用是编写代码和编译</p><p><code>STC-ISP</code>的作用是将<code>keil4</code>得到的16进制码下载到我们的板子上</p><h2 id="keil4使用"><a href="#keil4使用" class="headerlink" title="keil4使用"></a>keil4使用</h2><ol><li>选一个位置存代码，新建文件夹</li><li>打开<code>keil4</code>，顶栏选择<code>Project</code>，再选择第一个<code>New Project</code>，找到刚才建的文件夹，自己写一个项目名，然后在<code>Atmel</code>中找到<code>AT89C52</code></li><li>新建c文件，保存在刚才建的项目文件夹中</li><li>在左侧项目栏中右键项目文件夹，找到<code>add</code>什么那个，然后把建的c文件加进去</li><li>改成16进制输出</li><li>写代码，编译</li></ol><h2 id="STC-ISP使用"><a href="#STC-ISP使用" class="headerlink" title="STC-ISP使用"></a>STC-ISP使用</h2><ol><li>点打开程序文件，打开要下载到板子上的.hex文件</li><li>点下载&#x2F;编程</li><li>按板子上的下载按钮完成下载</li></ol><hr><p>下面我们实现各个元件的控制</p><h1 id="各个基本元件控制"><a href="#各个基本元件控制" class="headerlink" title="各个基本元件控制"></a>各个基本元件控制</h1><h2 id="LED指示灯的控制"><a href="#LED指示灯的控制" class="headerlink" title="LED指示灯的控制"></a>LED指示灯的控制</h2><p>在蓝桥杯指定单片机上已经有了诸多外设，传感器等等，板子的内部电路固定。所以需要通过特定的电路来对电路原件做相应的控制，而不像大一的电子设计课一样需要自己连线，可以自己定每条线插在哪个口。</p><h3 id="电路部分"><a href="#电路部分" class="headerlink" title="电路部分"></a>电路部分</h3><p>板子上共有8个我们需要控制的LED，由一个三八译码器74HC138，一个锁存器74HC573，和或非门构成，而我们就需要通过改变这几个原件的输入输出从而控制LED亮灭，那我们一一来看一看电路图。</p><ul><li><strong>三八译码器（74HC138）</strong></li></ul><img src="/image/${fiilename}/ca6b90b2e3077bcbd1fb46538f3fa3b.png" alt="ca6b90b2e3077bcbd1fb46538f3fa3b" style="zoom:150%;" /><p>​简单的三八译码器，有三个输入控制对应的八个输出，符合二进制规律</p><p>​注意的是，该三八译码器八路输出中只有一路是Low，其他都是High</p><p>​P25, P26, P27连接HC138的 A, B, C输入端，分别对应二进制的第0位，第1位和第2位</p><p>​本次控制LED我们需要让Y4为Low，所以我们要让CBA为100时，此时二进制对应为4即Y4为Low，其余输出均为High</p><ul><li><strong>锁存器（74HC573）</strong></li></ul><p><img src="/image/$%7Bfiilename%7D/e2489def9312e404eaac29046a99369.png" alt="e2489def9312e404eaac29046a99369"></p><p>​有用的只有图中Y4C输入：</p><p>​Y4C为High，那么八个输出和八个输入保持一致（输出跟着输入随时变）</p><p>​Y4C为Low，那么八个输出并不改变（输出不跟着输入变，还是原来的输出值）</p><p>​那么Y4C是啥呢？如下：</p><img src="/image/${fiilename}/dbc69a7aff4b84f57d8a8c082498a4c.png" alt="dbc69a7aff4b84f57d8a8c082498a4c" style="zoom:200%;" /><p>​图有点糊，但没啥事</p><p>​WR一般都是0，Y4和Y4C相反</p><p>​所以在上面我们让CBA是100，Y4为Low，那么Y4C就是High，此时我们就可以顺利通过P0^1到8来控制八个小灯泡了，0为亮，1为灭，即P0 &#x3D; 0x00代表8个小灯泡全亮，P0 &#x3D; 0xff代表8个小灯泡全灭。</p><p>至此，有关LED的电路部分介绍完毕，我们开始进行代码的编写。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>整个51单片机编程使用的都是C语言，很好上手</p><ul><li><p>引入头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul><p>​引入此头文件之后我们可以用特定字母代表指定引脚，比如P2^5代表电路图中的P25</p><ul><li><p>对应引脚定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit HC138_A = P2^<span class="number">5</span>;</span><br><span class="line">sbit HC138_B = P2^<span class="number">6</span>;</span><br><span class="line">sbit HC138_C = P2^<span class="number">7</span>;</span><br></pre></td></tr></table></figure></li><li><p>延迟函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​每个延迟函数都这么写就行</p><ul><li><p><strong>LED控制函数</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LEDRunning</span><span class="params">()</span>&#123;   </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">//Y4 = 0</span></span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//跑马灯</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)&#123;</span><br><span class="line">P0 = <span class="number">0xff</span> &lt;&lt; i;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)&#123;</span><br><span class="line">P0 = ~(<span class="number">0xff</span> &lt;&lt; i);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8个LED整体闪三下</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0xff</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">LEDRunning();</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简简单单主函数，不断循环LED控制函数</p></li></ul><p>编写完代码下载到板子上，进行验证以及修改</p><p>至此，我们就可以顺利控制LED了</p><h2 id="继电器和蜂鸣器"><a href="#继电器和蜂鸣器" class="headerlink" title="继电器和蜂鸣器"></a>继电器和蜂鸣器</h2><h3 id="电路部分-1"><a href="#电路部分-1" class="headerlink" title="电路部分"></a>电路部分</h3><p><img src="/image/$%7Bfiilename%7D/055e11268c30d61c5937a455b638d2d.png" alt="055e11268c30d61c5937a455b638d2d"></p><p>如图，<code>N_RELAY</code>连的是继电器，<code>N_BUZZ</code>连的是蜂鸣器，相对应的输入分别是P04和P06，输入为High时工作。</p><p>和上面LED不同，与锁存器相连的是Y5C，所以要控制继电器和蜂鸣器，我们需要使74HC138的输出Y5为Low，其他输出为High，即CBA为101；</p><h3 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h3><ul><li><p>代码优化</p><p>由于本次涉及到了Y5C，我们可以写一个函数来决定HC138的输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(n)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">1</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">1</span>;</span><br><span class="line">HC138_A = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个函数，我们只需一个数字便可以得到我们想要的输出从而选择控制哪部分电路</p></li><li><p>控制继电器和蜂鸣器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继电器吸合</span></span><br><span class="line">InitHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x10</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蜂鸣器叫一下</span></span><br><span class="line">InitHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x40</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="共阳数码管"><a href="#共阳数码管" class="headerlink" title="共阳数码管"></a>共阳数码管</h2><p><img src="/image/$%7Bfiilename%7D/image-20240225160400292.png" alt="image-20240225160400292"></p><p>如图，Y6C控制数码管位置，Y7C控制数码管内容</p><p>Y6C: P0^0-7与com0-7相连，控制8个数码管的明灭</p><p>Y7C: 每个数字或字母由组成数码管的8个LED决定，对应如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SMG_duanma[<span class="number">18</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>,</span><br><span class="line">                                <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>,</span><br><span class="line">                                <span class="number">0x88</span>, <span class="number">0x80</span>, <span class="number">0xc6</span>, <span class="number">0xc0</span>, <span class="number">0x86</span>,</span><br><span class="line">                                <span class="number">0x8e</span>, <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h3><p>由于控制数码管内容的只有P0^1-7，所以在静态显示中，如果有多个数码管同时亮，则显示的内容一致</p><ul><li><p>数码管位置及内容控制函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowSMG_Bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat, <span class="type">unsigned</span> pos)</span>&#123;</span><br><span class="line"> <span class="comment">//数码管位置</span></span><br><span class="line">InitHC138(<span class="number">6</span>);</span><br><span class="line">P0 = <span class="number">0x01</span> &lt;&lt; pos;</span><br><span class="line"><span class="comment">//数码管内容</span></span><br><span class="line">InitHC138(<span class="number">7</span>);</span><br><span class="line">P0 = SMG_duanma[dat]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>8个数码管依次亮</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SMG_Static</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line"> ShowSMG_Bit(i,i);  </span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态显示"><a href="#动态显示" class="headerlink" title="动态显示"></a>动态显示</h3><p>动态显示是根据人眼的<strong>视觉暂留现象</strong>以及发光二极管的<strong>余晖效应</strong>，只要8个LED闪的够快，那么在看起来就是一直亮的。</p><p>动态显示可以大大节省I&#x2F;O端口，而且功耗低</p><ul><li><p>动态显示代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SMG_Dynamic</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;   </span><br><span class="line">ShowSMG_Bit(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">Delay(<span class="number">500</span>);  </span><br><span class="line">    <span class="comment">//延迟也不能太短，LED点亮也需要时间，太短会让数码管看起来很暗</span></span><br><span class="line">ShowSMG_Bit(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">Delay(<span class="number">500</span>); </span><br><span class="line">ShowSMG_Bit(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">3</span>,<span class="number">3</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">4</span>,<span class="number">4</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">5</span>,<span class="number">5</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">6</span>,<span class="number">6</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">7</span>,<span class="number">7</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态显示的延迟函数</p><p>动态显示的延迟函数不能像之前的一样，而应该在延迟函数的<code>while</code>函数中一直进行动态显示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_Dynamic</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(t--)&#123;</span><br><span class="line"> SMG_Dynamic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">SMG_Static();</span><br><span class="line">SMG_Dynamic();</span><br><span class="line">Delay_Dynamic(<span class="number">100</span>);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​这样我们就可以随意控制8个数码管显示任何数字以及实现我们想要完成的变化了</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><h3 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h3><p>单个独立按键内部结构如下图所示，按下按键时输出低电平（接地），松开输出高电平（接VCC电源了）</p><img src="/image/${fiilename}/image-20240226182037139.png" alt="image-20240226182037139" style="zoom:50%;" /><p>独立按键共有四个：S7, S6, S5, S4，电路图如下所示，其中最左侧一列四个为独立按键</p><p><img src="/image/$%7Bfiilename%7D/image-20240226175148420.png" alt="image-20240226175148420"></p><p>将<code>J5</code>跳帽连接2,3引脚切换至独立按键模式</p><p>4个独立按键电路非常简单，P3^0-3依次连接独立按键的S7, S6, S5, S4</p><p>在代码中只需将S与P3相对应：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit S7 = P3^<span class="number">0</span>;</span><br><span class="line">sbit S6 = P3^<span class="number">1</span>;</span><br><span class="line">sbit S5 = P3^<span class="number">2</span>;</span><br><span class="line">sbit S4 = P3^<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在按键操作的代码中，我们需要做去抖动处理，从而识别有效按键，比如下面代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(S7 == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line">L1 = <span class="number">0</span>；</span><br><span class="line">            <span class="keyword">while</span>(S7 == <span class="number">0</span>);</span><br><span class="line">            L1 = <span class="number">1</span>；</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过使用<code>Delay(100)</code>实现了去抖动。</p><p>S7按下则L1亮，松开则灭</p><p>同时，我们用独立按键控制灯泡明灭会遇到两种情况：第一种情况就是上述的按下灯亮，松开灯灭；第二种就是按下灯亮，松开灯不灭，再次按下该按键灯才灭。第二种情况可以如下实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sta表示当前状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (sta == <span class="number">0</span>)&#123;</span><br><span class="line">sta = <span class="number">1</span>;</span><br><span class="line">L1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sta == <span class="number">1</span>)&#123;</span><br><span class="line">sta = <span class="number">0</span>;</span><br><span class="line"> L1 = <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(S7 == <span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码<code>if</code>判断的最后，我们使用了<code>while(S7 == 0);</code>从而避免按S7的时候程序反复进入该<code>if</code>判断中，这样可以使得按一下按键只进入一次<code>if</code>判断语句。</p><h3 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h3><p><strong>电路部分</strong></p><p>将<code>J5</code>跳帽连接1,2引脚切换至矩阵键盘模式</p><img src="/image/${fiilename}/image-20240226185144689.png" alt="image-20240226185144689" style="zoom:50%;" /><p>与独立按键不同，矩阵键盘左端不接地，而是连接I&#x2F;O输入，当左端输入为0且右端输出为0时，说明该按键被按下</p><p>所以，我们需要扫描按键，即逐行接低电平，检测每列输出，输出低电平则可以锁定行列坐标</p><p><img src="/image/$%7Bfiilename%7D/image-20240226175148420.png" alt="image-20240226175148420"></p><p><strong>代码部分</strong></p><p>首先，我们将行用R1-4表示，列用C1-4表示（由于我们引用的<code>reg52.h</code>头文件中没有P4端口，所以我们需要提前定义一下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义P4口， 电路图中P36为P42，P37为P44</span></span><br><span class="line">sfr P4 = <span class="number">0xc0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//R代表矩阵行，C代表矩阵列</span></span><br><span class="line">sbit R1 = P3^<span class="number">0</span>;</span><br><span class="line">sbit R2 = P3^<span class="number">1</span>;</span><br><span class="line">sbit R3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit R4 = P3^<span class="number">3</span>;</span><br><span class="line">sbit C4 = P3^<span class="number">4</span>;</span><br><span class="line">sbit C3 = P3^<span class="number">5</span>;</span><br><span class="line">sbit C2 = P4^<span class="number">2</span>;</span><br><span class="line">sbit C1 = P4^<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>然后，我们开始逐行扫描矩阵键盘</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeyMul</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//第一行</span></span><br><span class="line">R1 = <span class="number">0</span>;</span><br><span class="line">R2 = R3 = R4 = <span class="number">1</span>; </span><br><span class="line">C1 = C2 = C3 = C4 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (C1 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C1 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C2 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C2 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C3 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C3 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C4 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C4 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二、三、四行同理，复制粘贴略加改动即可</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们便可以确定哪个按键被按下，同时在对应的if判断语句中写下我们要进行的操作即可实现矩阵键盘相关的控制。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>在单片机中，内设和外设的主要交互方式有两种：轮询和中断，中断的相关原理跟计组中的中断一样</p><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>在51单片机中，有5个中断源（要记住每个中断源对应的终端号0-4）：</p><ol start="0"><li><p><code>INT0</code>：外部中断0</p></li><li><p><code>IF0</code>：定时&#x2F;计数器0</p></li><li><p><code>INT1</code>：外部中断1</p></li><li><p><code>IF0</code>：定时&#x2F;计数器1</p></li><li><p><code>R1/T1</code>：串口中断</p></li></ol><p>中断系统结构如下图所示：</p><p><img src="/image/$%7Bfiilename%7D/image-20240302140049460.png" alt="image-20240302140049460"></p><p>按照该图从左到右的顺序：</p><ul><li>最左段的表示五个中断源相应的输入</li><li><code>IT0</code>和<code>IT1</code>置1时表示响应下降信号，置0表示响应高电平</li><li>在<code>IE</code>寄存器中，EA表示中断总开关，如果想要相应中断，EA必须置1；EA左边的那五个则对应五个中断源各自的开关，同样置1相应</li><li><code>IP</code>寄存器用来设置相应优先级，一般用不到</li></ul><h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p>一般情况下，中断的处理函数有两个，一个是中断初始化函数，一个是中断服务函数</p><p><strong>中断初始化函数</strong></p><p>其实就是对中断相关开关进行赋值，初始化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init_INT0</span><span class="params">()</span> &#123;</span><br><span class="line"> IT0 = <span class="number">1</span>;</span><br><span class="line"> EX0 = <span class="number">1</span>;</span><br><span class="line"> EA = <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在主函数里最前面引用一下即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Init_INT0();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">Working();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中断服务函数</strong></p><p>中断服务函数有特殊格式要求：</p><p><code>void 函数名() interrupt 中断号</code></p><p>比如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ServiceINT0</span><span class="params">()</span> interrupt 0  &#123;</span><br><span class="line">L8 = <span class="number">0</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">   L8 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以实现中断处理了</p><p>单片机默认的<code>INT0</code>中断对应的按键为<code>S5</code>，要注意将<code>J5</code>跳帽链接23引脚</p><p>这样当我们按下<code>S5</code>时，我们会发现板子停止原来的工作，开始执行中断服务函数中我们设定的操作，当设定操作完成，板子又会继续原来的工作，即完成了一次中断</p><h2 id="计数器和定时器"><a href="#计数器和定时器" class="headerlink" title="计数器和定时器"></a>计数器和定时器</h2><h3 id="计数原理"><a href="#计数原理" class="headerlink" title="计数原理"></a>计数原理</h3><p>计数器每收到一个脉冲，就会加一，当计数值累计至全为1时（8位255,13位8191,16位65535），再输入一个计数脉冲，计数器就会溢出回零，同时向内核发出中断请求，从而完成计数操作</p><p>计时器和定时器的控制寄存器包括：</p><ul><li>计数初值寄存器<code>TH0/1，TL0/1</code>：我们知道，计数器只有在累计至各位全为1时才会发出中断请求。所以当我们要计数特定值时，我们就需要给计数器一个初始值：全为1时计数 - 我们要计的数，这样当计数器加上我们想要计的值时，他就会刚好溢出并发出中断请求</li><li>模式控制器<code>TMOD</code>：</li></ul><p><img src="/image/$%7Bfiilename%7D/image-20240302210350301.png" alt="image-20240302210350301"></p><ul><li>中断标志寄存器<code>TCON</code>：</li></ul><p><img src="/image/$%7Bfiilename%7D/image-20240302211835416.png" alt="image-20240302211835416"></p><p>在<code>TCON</code>中，与计数器启动有关的位为<code>TR0</code>和<code>TR1</code>，这两位置1时，分别控制计数器0和计数器1的启动</p><h3 id="代码部分-2"><a href="#代码部分-2" class="headerlink" title="代码部分"></a>代码部分</h3><p>计数器&#x2F;定时器的编程方式也较为固定：</p><ol><li>配置工作模式，即给<code>TMOD</code>寄存器赋一个初值来确定模式</li><li>计算计数器初值，将高八位赋给<code>TH0/1</code>，第八位赋给<code>TL0/1</code></li><li>使能定时&#x2F;计数器中断，即<code>ET0/1</code>置1（见上面中断放的那张灰色图）</li><li>打开总中断，即<code>EA=1</code></li><li>启动定时器，即<code>TR0/1=1</code></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitTimer0</span><span class="params">()</span> &#123;</span><br><span class="line"> TMOD = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">//计数50ms，即50000次脉冲</span></span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">ET0 = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一个中断服务函数：</p><ul><li>先初始化计数器，还计那么多数</li><li>再根据题意完成我们要的操作，比如一个定时器最多也就计65.5ms，当我们需要定的时超过这个时，我们就需要设置一个<code>count</code>来记录定时器溢出次数，这样就可以在相应溢出次数时完成我们需要的操作</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">    <span class="comment">//初始化计数器，再计50000次，完成循环</span></span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">count++;</span><br><span class="line">    <span class="comment">//执行我们需要的操作</span></span><br><span class="line"><span class="keyword">if</span> ((count % <span class="number">10</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> L1 = ~L1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">100</span>) &#123;</span><br><span class="line"> L8 = ~L8;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器实现秒表功能"><a href="#定时器实现秒表功能" class="headerlink" title="定时器实现秒表功能"></a>定时器实现秒表功能</h3><p>上面介绍了计数器和定时器最基本的使用方法并简单计时，下面我们来通过更复杂一点的代码并结合之前所学的知识来实现秒表功能</p><p>该功能涉及到内容：</p><ul><li>数码管的动态显示</li><li>独立按键的应用</li><li>定时器</li></ul><p><strong>我们要实现的具体功能如下：</strong></p><p>我们利用数码管设计一个秒表，使其具有清零、暂停、启动功能：</p><ol><li>显示格式为：分（两位）- 秒（两位） - 每0.05s（两位：即满20向前一位秒进1）</li><li>独立按键控制（按键按下即为有效）：<code>S4</code>：暂停&#x2F;启动，<code>S5</code>：清零</li></ol><p><strong>设计思路：</strong></p><ol><li>实现<code>HC138</code>选择函数来选择6（数码管位置）还是7（数码管内容）</li><li>数码管显示函数：通过传入参数位置和内容来使特定一位显示特定内容</li><li>时间显示函数：调用数码管显示函数，利用动态显示来显示每一位该显示的内容</li><li>定时器相关函数：启动函数和中断服务函数</li><li>按键扫描函数：看看<code>S4</code>和<code>S5</code>有没有被按下（做去抖动处理）</li></ol><p><strong>代码实现：</strong></p><p>这里直接贴上全部代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SMG_duanma[<span class="number">18</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>,</span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x80</span>, <span class="number">0xc6</span>, <span class="number">0xc0</span>, <span class="number">0x86</span>, <span class="number">0x8e</span>,</span><br><span class="line"><span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;</span><br><span class="line"><span class="comment">//对应按键定义</span></span><br><span class="line">sbit S4 = P3^<span class="number">3</span>;</span><br><span class="line">sbit S5 = P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> minute = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> second = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> t_50ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> channel)</span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (channel) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xa0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xc0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xe0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数码管</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplaySMG_Bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> value, <span class="type">unsigned</span> <span class="type">char</span> pos)</span> &#123;</span><br><span class="line"> SelectHC138(<span class="number">6</span>);</span><br><span class="line"> P0 = <span class="number">0x01</span> &lt;&lt; pos;</span><br><span class="line"> SelectHC138(<span class="number">7</span>);</span><br><span class="line"> P0 = SMG_duanma[value];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelaySMG</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span> &#123;</span><br><span class="line"> <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayTime</span><span class="params">()</span> &#123;</span><br><span class="line">DisplaySMG_Bit((t_50ms % <span class="number">10</span>), <span class="number">7</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((t_50ms / <span class="number">10</span>), <span class="number">6</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit(<span class="number">16</span>, <span class="number">5</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((second % <span class="number">10</span>), <span class="number">4</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((second / <span class="number">10</span>), <span class="number">3</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit(<span class="number">16</span>, <span class="number">2</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">DisplaySMG_Bit((minute % <span class="number">10</span>), <span class="number">1</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>); </span><br><span class="line">DisplaySMG_Bit((minute / <span class="number">10</span>), <span class="number">0</span>);</span><br><span class="line">DelaySMG(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器相关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitTimer0</span><span class="params">()</span> &#123;</span><br><span class="line">TMOD = <span class="number">0x01</span>;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">ET0 = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">t_50ms++;</span><br><span class="line"><span class="keyword">if</span> (t_50ms == <span class="number">20</span>) &#123;</span><br><span class="line">second++;</span><br><span class="line">t_50ms = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (second == <span class="number">60</span>) &#123;</span><br><span class="line">minute++;</span><br><span class="line">second = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minute &gt; <span class="number">99</span>) &#123;</span><br><span class="line">minute = <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键扫描</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayK</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//暂停</span></span><br><span class="line"><span class="keyword">if</span> (S4 == <span class="number">0</span>) &#123;</span><br><span class="line"> DelayK(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S4 == <span class="number">0</span>) &#123;</span><br><span class="line">TR0 = ~TR0;</span><br><span class="line"><span class="keyword">while</span> (S4 == <span class="number">0</span>) &#123;</span><br><span class="line"> DisplayTime();</span><br><span class="line">&#125;     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清零</span></span><br><span class="line"><span class="keyword">if</span> (S5 == <span class="number">0</span>) &#123;</span><br><span class="line"> DelayK(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S5 == <span class="number">0</span>) &#123;</span><br><span class="line">minute = <span class="number">0</span>;</span><br><span class="line">second = <span class="number">0</span>;</span><br><span class="line">t_50ms = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S5 == <span class="number">0</span>) &#123;</span><br><span class="line"> DisplayTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">InitTimer0();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ScanKeys();</span><br><span class="line">DisplayTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，通过上面代码，我们就完成了题目中的要求。</p><p>秒表功能将我们很多之前学到的知识结合到了一起，算是一个非常好的练习题，它带我们回顾前面学到的一些功能，很推荐去自己写一写。</p><h2 id="PWM脉宽调制"><a href="#PWM脉宽调制" class="headerlink" title="PWM脉宽调制"></a>PWM脉宽调制</h2><h3 id="调制原理"><a href="#调制原理" class="headerlink" title="调制原理"></a>调制原理</h3><p>PWM脉宽调制即在一个周期内，信号一部分为高电平，一部分为低电平</p><p>比如，当PWM脉宽信号频率为100Hz，占空比为60%时，此时PWM信号周期为0.01s，也就是100ms。那么在这100ms中，我们让前60ms为高电平，后40ms为低电平，就可以实现占空比60%了</p><p>我们通过PWM占空比，可以调节功率，比如控制LED的亮度（由于LED低电平亮，所以占空比越低LED越亮）</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以利用定时器来实现PWM脉宽调制</p><p>比如，我们设定PWM脉宽信号频率为100Hz，占空比可通过按键调节</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pwm_duty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitTimer0</span><span class="params">()</span> &#123;</span><br><span class="line">TMOD = <span class="number">0x01</span>;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">100</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">100</span>) % <span class="number">256</span>;</span><br><span class="line">ET0 = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>; </span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceTimer0</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line">TH0 = (<span class="number">65535</span> - <span class="number">100</span>) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65535</span> - <span class="number">100</span>) % <span class="number">256</span>;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= pwm_duty) &#123;</span><br><span class="line">L1 = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line"> L1 = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">100</span>) &#123;</span><br><span class="line"> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，我们就实现了PWM占空比为<code>pwm_duty/100</code>，我们再通过其他函数来改变<code>pwm_duty</code>的值便可以实现要求</p><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h3><p>波特率：串口每秒钟传输的位数（我们用的一般是9600）</p><p>我们通常使用定时器1的工作模式2（8位自动重装）来产生波特率，<code>TL1</code>作为脉冲计数寄存器，<code>TH1</code>作为自动重装寄存器，当计数到最大值溢出时，<code>TH1</code>的值会自动装到<code>TL1</code>中</p><p>所以，当我要产生9600BPS的波特率时</p><ul><li><code>SMOD = 0</code>时，<code>TH1 = TL1 = 0xfd</code></li><li><code>SMOD = 0</code>时，<code>TH1 = TL1 = 0xfa</code></li></ul><p>在串行口中有两个缓冲寄存器<code>SBUF</code>，一个是发送寄存器，一个是接收寄存器。</p><p>串行发送时，CPU向<code>SBUF</code>写入数据，发送完成后标志位<code>TI</code>会置1，这时候需要我们手动让<code>TI = 0</code></p><p>串行接收时，CPU从<code>SBUF</code>接收数据，内核接收到一个完整数据后，会将标志位<code>RI</code>置1，这时候我们从<code>SBUF</code>读取即可</p><p><img src="/image/$%7Bfiilename%7D/image-20240303205647340.png" alt="image-20240303205647340"></p><p>根据上图，我们在<code>Uart初始化函数</code>中，需要让<code>SCON = 0x50</code>。同时因为我们要用到定时器1，我们需要让<code>TMOD = 0x20</code>，并开启定时器1相关使能</p><p>同时由于我们使用的单片机与我们头文件引用的库并不完全相同，我们需要在文件最前面写<code>sfr AXUR = 0x8e</code>来将<code>AXUR</code>定义，并在初始化函数中让<code>AXUR = 0x00</code></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sfr AUXR = <span class="number">0x8e</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> urData = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Uart初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitUart</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//自动重装8位定时器</span></span><br><span class="line">TMOD = <span class="number">0x20</span>;</span><br><span class="line">    </span><br><span class="line">TH1 = <span class="number">0xfd</span>;</span><br><span class="line">TL1 = <span class="number">0xfd</span>;</span><br><span class="line">TR1 =<span class="number">1</span>;</span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">AUXR = <span class="number">0x00</span>;</span><br><span class="line">ES = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">SBUF = dat;</span><br><span class="line"><span class="keyword">while</span> (TI == <span class="number">0</span>);</span><br><span class="line">TI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceUart</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line"> <span class="keyword">if</span> (RI == <span class="number">1</span>) &#123;</span><br><span class="line">RI = <span class="number">0</span>;</span><br><span class="line">urData = SBUF; </span><br><span class="line">SendByte(urData + <span class="number">1</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">InitUart();</span><br><span class="line">SendByte(<span class="number">0x5a</span>);</span><br><span class="line">SendByte(<span class="number">0xa5</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码，我们并可以实现在单片机开机后向CPU发送5a和a5，并在接收到CPU发送的数据后加一再发回去</p><h3 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a>进阶应用</h3><p>那么接下来，我们对串口通信进行更难一点的应用来加强我们的理解</p><p>我们要实现的功能如下：</p><p><img src="/image/$%7Bfiilename%7D/image-20240303210605046.png" alt="image-20240303210605046"></p><p>那么对于略微复杂的问题，我们在敲代码之前一定要先想清楚我们都要干嘛:</p><ul><li>先初始化系统，关掉所有LED，蜂鸣器和继电器</li><li>初始化<code>Uart</code>（用到定时器1），对相关使能以及模式进行赋值</li><li>向上位机发送字符串<code>“Welcome to My System”</code></li><li>接受上位机发送的信号，并据此进行相应控制</li></ul><p>好的，上面就是我对这道题的全部思路，我的实现代码如下（为了体现整体逻辑，就不将代码拆开分功能实现了，直接全贴上来）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sfr AXUR = <span class="number">0x8e</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> channel)</span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (channel) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0xa0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对系统进行初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSystem</span><span class="params">()</span> &#123;</span><br><span class="line"> SelectHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line">SelectHC138(<span class="number">4</span>);</span><br><span class="line">P0 = <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口相关</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> command = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitUart</span><span class="params">()</span> &#123;</span><br><span class="line">TMOD = <span class="number">0x20</span>;</span><br><span class="line">TH1 = <span class="number">0xfd</span>;</span><br><span class="line">TL0 = <span class="number">0xfd</span>;</span><br><span class="line">TR1 = <span class="number">1</span>;</span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">AXUR = <span class="number">0x00</span>;</span><br><span class="line">ES = <span class="number">1</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ServiceUart</span><span class="params">()</span> interrupt 4 &#123;</span><br><span class="line"><span class="keyword">if</span> (RI == <span class="number">1</span>) &#123;</span><br><span class="line">command = SBUF;</span><br><span class="line">RI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">  SBUF = dat;</span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">TI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SendString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(*str) &#123;</span><br><span class="line">SendByte(*str++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DoCommand</span><span class="params">()</span> &#123;</span><br><span class="line">SelectHC138(<span class="number">4</span>);  <span class="comment">//也可以不写，系统初始化最后选择的是4</span></span><br><span class="line"> <span class="keyword">if</span> (command != <span class="number">0x00</span>) &#123;</span><br><span class="line"> <span class="keyword">switch</span> (command &amp; <span class="number">0xf0</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xa0</span>:</span><br><span class="line">                <span class="comment">//下面是利用位运算实现的相关控制，其实也可以使用if判断实现</span></span><br><span class="line">P0 = (P0 | <span class="number">0x0f</span>) &amp; (~command | <span class="number">0xf0</span>);</span><br><span class="line"> command = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xb0</span>:</span><br><span class="line">P0 = (P0 | <span class="number">0xf0</span>) &amp; ((~command &lt;&lt; <span class="number">4</span>) | <span class="number">0x0f</span>); </span><br><span class="line">  command = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xc0</span>:</span><br><span class="line">SendString(<span class="string">&quot;The System is Running...\r\n&quot;</span>);</span><br><span class="line">command = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">break</span>;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">InitSystem();</span><br><span class="line">InitUart();</span><br><span class="line">SendString(<span class="string">&quot;Welcome to My System\n&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">DoCommand();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
