<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS预习</title>
      <link href="/2024/02/25/OS%E9%A2%84%E4%B9%A0/"/>
      <url>/2024/02/25/OS%E9%A2%84%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul><li><p><strong>cd</strong></p><p>用法：<code>cd 目录</code></p><p>作用：切换到该目录（类似于打开文件夹）</p><p><code>cd /</code>：&#x2F; 代表根目录，即Linux文件系统的最顶层<br><code>cd ~</code>：~当前用户主目录，对于一般用户，主目录是<code>/home/用户名</code>；如果当前用户是系统管理员(root)用户，主目录是<code>/root</code><br><code>cd /etc/test</code>：切换到<code>etc</code>目录下的<code>test</code>目录（可以理解为打开<code>test</code>文件夹）</p><p><code>cd test</code>：cd命令支持相对路径，如果系统在<code>etc</code>目录，可以输入<code>cd test</code>直接访问<code>test</code>目录</p><p><code>cd .</code>：<code>.</code>表示当前目录<br><code>cd ..</code>：<code>..</code>表示上一级目录<br><code>cd -</code>：<code>-</code>表示上一次访问的目录</p></li><li><p><strong>ls</strong></p><p>用法：<code>ls [选项] [目录]</code> （<code>[]</code>代表可有可无）</p><p>作用：列出目录中的文件</p><p>常用选项：</p><p>​<code>-a</code>：显示隐藏的文件（文件名以 <code>.</code> 开头的文件）</p><p>​<code>-l</code>：每行只列出一个文件</p></li><li><p><strong>mkdir</strong></p><p>用法：<code>mkdir 目录</code></p><p>作用：创建一个新目录</p></li><li><p><strong>pwd</strong></p><p>用法：<code>pwd [选项]</code></p><p>作用：输出当前目录的绝对路径</p></li><li><p><strong>rmdir</strong></p><p>用法：<code>rmdir [选项] 目录</code></p><p>作用：删除一个空的目录。注意：只能是空目录</p></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件操作的对象是几乎所有文件，也包含目录</p><ul><li><p><strong>touch</strong></p><p>用法：<code>touch [选项] 文件名</code></p><p>作用：当文件不存在时创建新文件，当文件存在时更新文件的时间戳</p><p>注意：不能用<code>touch</code>新建目录，要使用<code>mkdir</code></p></li><li><p><strong>rm</strong></p><p>用法：<code>rm [选项] 文件</code></p><p>作用：删除文件</p><p>常用选项：</p><p>​<code>-r</code>：递归删除目录及其内容，删除非空目录必须有此选项，否则无法删除</p><p>​<code>-f</code>： 强制删除，不提示用户确认，忽略不存在的目录</p><p>​<code>-i</code>： 逐一提示用户确认每个将要被删除的文件</p><p>注意：<code>rm -rf</code>一定慎用，全删了，非必要不使用</p></li><li><p><strong>cp</strong></p><p>用法：<code>cp [选项] 源文件 目标路径</code></p><p>作用：将源文件（或目录）复制到目标路径对应的文件或目录</p><p>常用选项：</p><p>​<code>-r</code>：递归移动目录及其子目录内的所有内容</p></li><li><p><strong>mv</strong></p><p>用法：<code>mv [选项] 源文件 目标路径</code></p><p>作用：类似于剪切，将源文件移动至目标位置</p><p>常用选项：</p><p>​<code>-r</code>：递归移动目录及其子目录内的所有内容</p><p><code>mv</code>也可以用来重命名文件比如<code>mv test.txt test2.txt</code>就可以实现对<code>test.txt</code>的重命名</p></li><li><p><strong>diff</strong></p><p>用法：<code>diff [选项] 文件1 文件2</code></p><p>作用：比较两个纯文本文件的差异</p><p>常用选项：</p><p>​<code>-b</code>：不检查空白字符的不同</p><p>​<code>-B</code>：不检查空行</p><p>​<code>-q</code>：仅显示有无差异，不显示详细信息</p></li><li><p><strong>vim</strong></p><p>Vim是Linux系统下的一款开源编辑器，编辑效率很高，下面介绍Vim的基本输入操作</p><p>用法：</p><ol><li><code>vim 文件名</code></li><li>按<code>I</code>进入插入模式，可以开始输入文本内容</li><li>完成文件修改后，按<code>Esc</code>回到命令模式，再按<code>Shift + ;</code>进入底线命令模式，可以看到最后一行出现冒号。输入<code>w</code>并按回车可以保存文件，输入<code>q</code>并按回车可以关闭文件，也可以合并输入<code>wq</code>即可保存并关闭文件</li></ol></li></ul><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><ul><li><p><strong>find</strong></p><p>用法：<code>find [路径] 选项</code></p><p>作用：在给定路径下递归地查找文件，输出符合要求的文件的路径。如果没有给定路径，则在当前目录下查找。</p><p>常用选项： </p><p>​<code>-name 文件名</code> ：指定需要查找的文件名。</p><p>例如在当前目录下查找所有名为<code>test.c</code>文件的操作为<code>find -name test.c</code></p></li><li><p><strong>grep</strong></p><p>用法：<code>grep [选项] PATTERN FILE</code>（PATTERN是匹配字符串，FILE是文件或目录的路径） </p><p>作用：输出匹配字符串PATTERN的文件和相关的行</p><p>常用选项：</p><p>​<code>-a</code>：不忽略二进制数据进行搜索</p><p>​<code>-i</code>：忽略大小写差异</p><p>​<code>-r</code>：从目录中递归查找</p><p>​<code>-n</code>：显示行号</p></li><li><p><strong>tree</strong></p><p>用法：<code>tree [选项] [目录名]</code></p><p>作用：高级版的<code>ls</code>，输出目录下的文件树</p><p>常用选项：</p><p>​<code>-a</code>：列出全部文件（包含隐藏文件）</p><p>​<code>-d</code>：只列出目录</p></li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li><p><strong>man</strong></p><p>用法：<code>man [选项] 命令</code> 阅读完毕后按<code>Q</code>退出</p><p>作用：查看该命令的详细说明手册</p></li><li><p><strong>echo</strong></p><p>用法：<code>echo 要输出内容</code></p><p>作用：直接在终端输出内容</p></li></ul><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li><code>Ctrl + C</code>：终止当前程序执行。注意：在终端复制时就老老实实用右键复制，以免误杀进程。</li><li><code>Ctrl + Z</code>：挂起当前程序，暂停，放到后台<code>Ctrl + Z</code>挂起程序后会显示该程序挂起编号，若想要恢复该程序可以使用 <code>fg [job_spec]</code>即可，<code>job_spec</code> 即为挂起编号，不输入时默认为最近挂起进程。</li><li><code>Ctrl + D</code>：终止输入，在标准输入中输入<code>Ctrl+D</code>也意味着输入了一个 EOF。</li><li><code>Ctrl + L</code>：清屏，相当于命令<code>clear</code>。</li><li><code>方向键 上 下</code>：切换最近使用过的命令。</li></ul><h1 id="相关实用工具"><a href="#相关实用工具" class="headerlink" title="相关实用工具"></a>相关实用工具</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC包含了著名的 C 语言编译器 gcc</p><p>用法：<code>gcc [选项] 源代码文件</code></p><p>作用：编译该文件</p><p>我们可以先输入<code>gcc hello.c</code>编译<code>hello.c</code>文件并在目录下出现<code>a.out</code>文件，我们再通过命令<code>./a.out</code>执行<code>a.out</code>文件获得输出（注意：一定要有<code>./</code>）</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git-中文件的四种储存状态"><a href="#Git-中文件的四种储存状态" class="headerlink" title="Git 中文件的四种储存状态"></a>Git 中文件的四种储存状态</h2><p>一个文件，在 Git 目录中有以下四种状态：</p><ul><li>未跟踪（Untracked）：一个文件在储存库的版本信息中没有被记录过。比如在储存库中新建了一个文件，这个文件现在就是未跟踪的状态；在一个非空目录下使用 <code>git init</code> 来初始化一个空储存库，此时这个目录下的所有文件都处于未跟踪的状态。</li><li>未修改（Unmodified）：一个文件在跟踪之后一直没有改动过，或者改动已经被提交（即工作区的内容和储存库中的内容相同），则处于未修改状态。当我们修改这个文件时，则会使这个文件变成已修改状态。</li><li>已修改（Modified）：一个文件已经被修改（即工作区的内容和储存库中的内容不同），但还没有加入（<code>git add</code>) 到暂存区中。</li><li>已暂存（Staged）：一个文件已被加入暂存区。加入暂存区意味着将一个已修改的文件加入下次提交（<code>git commit</code>）需要存入储存库的文件清单中。</li></ul><p><img src="/image/$%7Bfiilename%7D/image-20240225232606403.png" alt="image-20240225232606403"></p><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><ul><li><p><code>git init</code>：把当前目录变成一个空的 Git 仓库，这样就可以对当前目录下的内容进行版本管理了。</p></li><li><p><code>git clone</code>：“克隆”一个已有的储存库到当前目录下。通常我们会从一个互联网地址（即 URL，统一资源定位符）进行克隆，所以一般这种操作可以理解为“下载”。</p></li><li><p><code>git status</code>：查看当前分支的状态，以及当前工作区的变动和暂存区的内容，便于我们对工作区的概况进行掌握。</p></li><li><p><code>git add</code>：把一个新文件或者已经修改过的文件加入暂存区中。在你完成一部分实验内容之后，可以使用<code>git add .</code> 将所有修改加入暂存区，也可以使用 <code>git add &lt;filename&gt;</code> 来将指定的文件加入暂存区。</p></li><li><p><code>git restore</code>：我们在修改一个文件之后，可能想要放弃这个修改。当这个文件还没有通过 <code>git add</code> 加入暂存区时，我们可以使用 <code>git restore &lt;filename&gt;</code> 来撤销对这个文件的修改，使其退回到上一个 commit 的状态。如果这个文件已经加入了暂存区，我们可以通过 <code>git restore --staged &lt;filename&gt;</code> 来取消暂存。</p></li><li><p><code>git checkout</code>：这个命令涉及到分支的知识，使用 <code>git checkout lab&lt;x&gt;</code> 可以切换到相应的分支。注意，在切换时，需要保证目前所有文件的状态均为“未修改”（没有修改过，或者已经提交）。</p></li><li><p><code>git commit</code>：使用 <code>git commit -m &lt;message&gt;</code> 这个命令将暂存区的修改提交到储存库中。当 message 参数有空格时需要把 message 用引号括起来。在提交时，要求给出一段说明性文字。这段文字可以任意填写，但建议按照提交内容填写，以保证多人协作时的可读性。</p></li><li><p><code>git push</code>：将本地的 commit 推送到一个远程仓库。</p></li><li><p><code>git pull</code>：将远程新建的分支下载到本地，并且将远端的更改合并到当前的分支。在利用评测机进行实验分支的初始化之后，可以在开发机中使用这个命令来将新的分支下载到本地。</p><p><img src="/image/$%7Bfiilename%7D/image-20240225232151061.png" alt="image-20240225232151061"></p></li></ul><p>​<img src="/image/$%7Bfiilename%7D/image-20240225232215486.png" alt="image-20240225232215486"></p><p>在这里贴一张gitlab上关于git操作的说明，感觉还较为全面</p><p>常用操作就是：</p><ol><li><p>先<code>git clone 上传目标库的ssh</code></p></li><li><p>将想要上传的文件拖进<code>git clone</code>出的文件夹中</p></li><li><p><code>git add .</code></p></li><li><p><code>git commit -m &quot;提交说明&quot;</code></p></li><li><p><code>git push</code></p><p>这样就可以将我们要上传的文件成功上传到库中了</p></li></ol><p><img src="/image/$%7Bfiilename%7D/fda83e04fcb352a17c3fc3a3295f7d4.png" alt="fda83e04fcb352a17c3fc3a3295f7d4"></p><h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><h2 id="shell脚本执行"><a href="#shell脚本执行" class="headerlink" title="shell脚本执行"></a>shell脚本执行</h2><p>Shell 脚本执行时，如果没有权限，我们可以使用下面的命令手动添加“执行”权限。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">chmod +x 文件名</span><br></pre></td></tr></table></figure><h2 id="Bash-Shell-语法基础"><a href="#Bash-Shell-语法基础" class="headerlink" title="Bash Shell 语法基础"></a>Bash Shell 语法基础</h2><p>首先用 <code>touch</code> 命令创建一个新文件 <code>hello.sh</code>，使用 Vim 输入以下内容：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#My first Shell script!</span><br><span class="line"><span class="built_in">echo</span> &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure><p>第一行：指定脚本的默认运行程序（即解释器）。在这里指定为 bash，这是我们最常使用的脚本运行程序。</p><blockquote><p>其中，<code>#!</code> 出现在脚本文件的第一行的前两个字符，被称为 Shebang。当文件中存在 Shebang 的情况下，程序加载器会分析 Shebang 后面的内容，并且将这些内容作为脚本文件的解释器。</p></blockquote><p>第二行：注释。注释以 <code>#</code> 开头。</p><p>第三行：输出。将 <code>echo</code> 命令后面的字符串输出。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义方式为：<code>var_name=value</code>（注意：&#x3D; 两边<strong>不允许有空格</strong>）</p><p> 使用<code>$var_name</code> 可以获取变量的值。在使用时，建议在变量名的两端加一个花括号（形如 <code>$&#123;var_name&#125;</code>），以帮助解释器识别变量的边界，避免歧义。</p><p>例如：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">str=&quot;Hello, world!&quot;</span><br><span class="line"><span class="built_in">echo</span> $str</span><br></pre></td></tr></table></figure><h3 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h3><p>我们将<code>hello.sh</code>的内容修改为：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">str=&quot;Hello, $<span class="number">1</span> and $<span class="number">2</span>!&quot;</span><br><span class="line"><span class="built_in">echo</span> $str</span><br></pre></td></tr></table></figure><p>再输入<code>$ ./hello.sh world OS</code>我们可以得到<code>Hello, world and OS!</code>即用执行命令中的<code>world</code>和<code>OS</code>替代脚本中的<code>$1</code>和<code>$2</code></p><p>如果命令中的参数不够，则不输出脚本中多出来的脚本参数；</p><p>除了 <code>$1</code>、<code>$2</code> ，还有一些其他的特殊变量：</p><ul><li><code>$#</code> ：传递的参数个数；</li><li><code>$*</code>：一个字符串，内容是传递的全部参数。</li></ul><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><ul><li><p><strong>if 语句</strong></p><p><code>if</code> 语句块的格式如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line">then</span><br><span class="line">    command11</span><br><span class="line">    command12</span><br><span class="line">    ......</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    command21</span><br><span class="line">    command22</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command31</span><br><span class="line">    command32</span><br><span class="line">    ......</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中，<code>fi</code> 是“if”的倒写，代表 <code>if</code> 语句块的结束；<code>elif</code> 意为“else if”。<code>elif</code> 和 <code>else</code> 可以按需省略。</p><p>下面举例说明：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">if</span> (( $<span class="number">1</span> &gt; $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first &gt; second&quot;</span><br><span class="line">elif (( $<span class="number">1</span> &lt; $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first &lt; second&quot;</span><br><span class="line">elif (( $<span class="number">1</span> == $<span class="number">2</span> ))</span><br><span class="line">then</span><br><span class="line">        <span class="built_in">echo</span> &quot;first == second&quot;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> &quot;I don&#x27;t know...&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中 <code>(())</code> 是用于比较<strong>整数</strong>之间大小的表达方式。传入字符串或浮点数，则是未定义的行为。</p></li><li><p><strong>while语句</strong></p><p><code>while</code> 语句块的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>其中 <code>done</code> 表示“do”语句块的结束。下面举例说明。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="built_in">mkdir</span> files</span><br><span class="line"><span class="built_in">cd</span> files</span><br><span class="line">i=<span class="number">1</span></span><br><span class="line">while (($i &lt;= $<span class="number">1</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        touch &quot;file$i.txt&quot;</span><br><span class="line">        let i=i+<span class="number">1</span> # or i=$((i+<span class="number">1</span>))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这里，<code>let</code> 是为变量赋值的命令，与之等价地，也可以使用 <code>i=$((i+1))</code>。</p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Shell 脚本也支持<strong>函数</strong>。函数的定义方式如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">function fun_name() &#123;</span><br><span class="line">    body...</span><br><span class="line">    return int_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>function</code> 和 <code>()</code> 可以省略其中一个。其中返回语句是可选的，函数可以不返回值。<code>int_value</code> 是一个0 - 255之间的整数，返回其他值是未定义的行为，一般会返回一个错误的结果。</p><p>函数的调用方法如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">fun_name param1 param2 ... paramN</span><br></pre></td></tr></table></figure><p>其中第 N 个参数在函数体内使用 <code>$N</code> 来获取，且不需要在函数定义开头声明。值得注意的是，当 N&gt;&#x3D;10 时，需要用 <code>$&#123;N&#125;</code> 来获取参数，否则 <code>$</code> 只会带第一位数字。如果函数有返回值，则在函数调用的后面需要使用 <code>$?</code> 获取返回值。例子如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">function fun1() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;Hello, world!&quot;</span><br><span class="line">&#125;</span><br><span class="line">function fun2() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;I&#x27;ve got &quot;$<span class="number">1</span>&quot; and &quot;$<span class="number">2</span>&quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">function fun3() &#123;</span><br><span class="line">        <span class="built_in">echo</span> &quot;I&#x27;m computing first + second!&quot;</span><br><span class="line">        return $(($<span class="number">1</span> + $<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line">fun1</span><br><span class="line">fun2 <span class="number">2</span> <span class="number">3</span></span><br><span class="line">fun3 <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">echo</span> &quot;The sum is &quot;$?&quot;.&quot;</span><br></pre></td></tr></table></figure><p>其中，<code>$(($1 + $2))</code> 的意思是先计算 <code>$1 + $2</code> 的值。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机——蓝桥杯备赛</title>
      <link href="/2024/02/23/%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/"/>
      <url>/2024/02/23/%E5%8D%95%E7%89%87%E6%9C%BA%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>蓝桥杯比赛指定单片机跟51单片机差不多，可以通过淘宝国信长天购买。</p><p>本次学习跟着<a href="https://www.bilibili.com/video/BV1Bt41187hw/?vd_source=59e4e13f0e1002ef3a96e7a6170a57aa">b站小蜜蜂老师的视频</a></p><p>使用的相关软件为 <code>keil4</code> 和 <code>STC-ISP</code></p><h1 id="相关软件使用"><a href="#相关软件使用" class="headerlink" title="相关软件使用"></a>相关软件使用</h1><p><code>keil4</code>作用是编写代码和编译</p><p><code>STC-ISP</code>的作用是将<code>keil4</code>得到的16进制码下载到我们的板子上</p><h2 id="keil4使用"><a href="#keil4使用" class="headerlink" title="keil4使用"></a>keil4使用</h2><ol><li>选一个位置存代码，新建文件夹</li><li>打开<code>keil4</code>，顶栏选择<code>Project</code>，再选择第一个<code>New Project</code>，找到刚才建的文件夹，自己写一个项目名，然后在<code>Atmel</code>中找到<code>AT89C52</code></li><li>新建c文件，保存在刚才建的项目文件夹中</li><li>在左侧项目栏中右键项目文件夹，找到<code>add</code>什么那个，然后把建的c文件加进去</li><li>改成16进制输出</li><li>写代码，编译</li></ol><h2 id="STC-ISP使用"><a href="#STC-ISP使用" class="headerlink" title="STC-ISP使用"></a>STC-ISP使用</h2><ol><li>点打开程序文件，打开要下载到板子上的.hex文件</li><li>点下载&#x2F;编程</li><li>按板子上的下载按钮完成下载</li></ol><hr><p>下面我们实现各个元件的控制</p><h1 id="各元件控制"><a href="#各元件控制" class="headerlink" title="各元件控制"></a>各元件控制</h1><h2 id="LED指示灯的控制"><a href="#LED指示灯的控制" class="headerlink" title="LED指示灯的控制"></a>LED指示灯的控制</h2><p>在蓝桥杯指定单片机上已经有了诸多外设，传感器等等，板子的内部电路固定。所以需要通过特定的电路来对电路原件做相应的控制，而不像大一的电子设计课一样需要自己连线，可以自己定每条线插在哪个口。</p><h3 id="电路部分"><a href="#电路部分" class="headerlink" title="电路部分"></a>电路部分</h3><p>板子上共有8个我们需要控制的LED，由一个三八译码器74HC138，一个锁存器74HC573，和或非门构成，而我们就需要通过改变这几个原件的输入输出从而控制LED亮灭，那我们一一来看一看电路图。</p><ul><li><strong>三八译码器（74HC138）</strong></li></ul><img src="/image/${fiilename}/ca6b90b2e3077bcbd1fb46538f3fa3b.png" alt="ca6b90b2e3077bcbd1fb46538f3fa3b" style="zoom:150%;" /><p>​简单的三八译码器，有三个输入控制对应的八个输出，符合二进制规律</p><p>​注意的是，该三八译码器八路输出中只有一路是Low，其他都是High</p><p>​P25, P26, P27连接HC138的 A, B, C输入端，分别对应二进制的第0位，第1位和第2位</p><p>​本次控制LED我们需要让Y4为Low，所以我们要让CBA为100时，此时二进制对应为4即Y4为Low，其余输出均为High</p><ul><li><strong>锁存器（74HC573）</strong></li></ul><p><img src="/image/$%7Bfiilename%7D/e2489def9312e404eaac29046a99369.png" alt="e2489def9312e404eaac29046a99369"></p><p>​有用的只有图中Y4C输入：</p><p>​Y4C为High，那么八个输出和八个输入保持一致（输出跟着输入随时变）</p><p>​Y4C为Low，那么八个输出并不改变（输出不跟着输入变，还是原来的输出值）</p><p>​那么Y4C是啥呢？如下：</p><img src="/image/${fiilename}/dbc69a7aff4b84f57d8a8c082498a4c.png" alt="dbc69a7aff4b84f57d8a8c082498a4c" style="zoom:200%;" /><p>​图有点糊，但没啥事</p><p>​WR一般都是0，Y4和Y4C相反</p><p>​所以在上面我们让CBA是100，Y4为Low，那么Y4C就是High，此时我们就可以顺利通过P0^1到8来控制八个小灯泡了，0为亮，1为灭，即P0 &#x3D; 0x00代表8个小灯泡全亮，P0 &#x3D; 0xff代表8个小灯泡全灭。</p><p>至此，有关LED的电路部分介绍完毕，我们开始进行代码的编写。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>整个51单片机编程使用的都是C语言，很好上手</p><ul><li><p>引入头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul><p>​引入此头文件之后我们可以用特定字母代表指定引脚，比如P2^5代表电路图中的P25</p><ul><li><p>对应引脚定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit HC138_A = P2^<span class="number">5</span>;</span><br><span class="line">sbit HC138_B = P2^<span class="number">6</span>;</span><br><span class="line">sbit HC138_C = P2^<span class="number">7</span>;</span><br></pre></td></tr></table></figure></li><li><p>延迟函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​每个延迟函数都这么写就行</p><ul><li><p><strong>LED控制函数</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LEDRunning</span><span class="params">()</span>&#123;   </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">//Y4 = 0</span></span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//跑马灯</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)&#123;</span><br><span class="line">P0 = <span class="number">0xff</span> &lt;&lt; i;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)&#123;</span><br><span class="line">P0 = ~(<span class="number">0xff</span> &lt;&lt; i);</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8个LED整体闪三下</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0xff</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">LEDRunning();</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简简单单主函数，不断循环LED控制函数</p></li></ul><p>编写完代码下载到板子上，进行验证以及修改</p><p>至此，我们就可以顺利控制LED了</p><h2 id="继电器和蜂鸣器"><a href="#继电器和蜂鸣器" class="headerlink" title="继电器和蜂鸣器"></a>继电器和蜂鸣器</h2><h3 id="电路部分-1"><a href="#电路部分-1" class="headerlink" title="电路部分"></a>电路部分</h3><p><img src="/image/$%7Bfiilename%7D/055e11268c30d61c5937a455b638d2d.png" alt="055e11268c30d61c5937a455b638d2d"></p><p>如图，<code>N_RELAY</code>连的是继电器，<code>N_BUZZ</code>连的是蜂鸣器，相对应的输入分别是P04和P06，输入为High时工作。</p><p>和上面LED不同，与锁存器相连的是Y5C，所以要控制继电器和蜂鸣器，我们需要使74HC138的输出Y5为Low，其他输出为High，即CBA为101；</p><h3 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h3><ul><li><p>代码优化</p><p>由于本次涉及到了Y5C，我们可以写一个函数来决定HC138的输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(n)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">0</span>;</span><br><span class="line">HC138_A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">1</span>;</span><br><span class="line">HC138_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">HC138_C = <span class="number">1</span>;</span><br><span class="line">HC138_B = <span class="number">1</span>;</span><br><span class="line">HC138_A = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个函数，我们只需一个数字便可以得到我们想要的输出从而选择控制哪部分电路</p></li><li><p>控制继电器和蜂鸣器</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继电器吸合</span></span><br><span class="line">InitHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x10</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蜂鸣器叫一下</span></span><br><span class="line">InitHC138(<span class="number">5</span>);</span><br><span class="line">P0 = <span class="number">0x40</span>;</span><br><span class="line">Delay(<span class="number">60000</span>);</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="共阳数码管"><a href="#共阳数码管" class="headerlink" title="共阳数码管"></a>共阳数码管</h2><p><img src="/image/$%7Bfiilename%7D/image-20240225160400292.png" alt="image-20240225160400292"></p><p>如图，Y6C控制数码管位置，Y7C控制数码管内容</p><p>Y6C: P0^0-7与com0-7相连，控制8个数码管的明灭</p><p>Y7C: 每个数字或字母由组成数码管的8个LED决定，对应如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SMG_duanma[<span class="number">18</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>,</span><br><span class="line">                                <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>,</span><br><span class="line">                                <span class="number">0x88</span>, <span class="number">0xc6</span>, <span class="number">0xc0</span>, <span class="number">0x86</span>, <span class="number">0x8e</span>,</span><br><span class="line">                                <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h3><p>由于控制数码管内容的只有P0^1-7，所以在静态显示中，如果有多个数码管同时亮，则显示的内容一致</p><ul><li><p>数码管位置及内容控制函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowSMG_Bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat, <span class="type">unsigned</span> pos)</span>&#123;</span><br><span class="line"> <span class="comment">//数码管位置</span></span><br><span class="line">InitHC138(<span class="number">6</span>);</span><br><span class="line">P0 = <span class="number">0x01</span> &lt;&lt; pos;</span><br><span class="line"><span class="comment">//数码管内容</span></span><br><span class="line">InitHC138(<span class="number">7</span>);</span><br><span class="line">P0 = SMG_duanma[dat]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>8个数码管依次亮</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SMG_Static</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line"> ShowSMG_Bit(i,i);  </span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">Delay(<span class="number">50000</span>);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态显示"><a href="#动态显示" class="headerlink" title="动态显示"></a>动态显示</h3><p>动态显示是根据人眼的<strong>视觉暂留现象</strong>以及发光二极管的<strong>余晖效应</strong>，只要8个LED闪的够快，那么在看起来就是一直亮的。</p><p>动态显示可以大大节省I&#x2F;O端口，而且功耗低</p><ul><li><p>动态显示代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SMG_Dynamic</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;   </span><br><span class="line">ShowSMG_Bit(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">Delay(<span class="number">500</span>);  </span><br><span class="line">    <span class="comment">//延迟也不能太短，LED点亮也需要时间，太短会让数码管看起来很暗</span></span><br><span class="line">ShowSMG_Bit(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">Delay(<span class="number">500</span>); </span><br><span class="line">ShowSMG_Bit(<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">3</span>,<span class="number">3</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">4</span>,<span class="number">4</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">5</span>,<span class="number">5</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">6</span>,<span class="number">6</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">ShowSMG_Bit(<span class="number">7</span>,<span class="number">7</span>); </span><br><span class="line">Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态显示的延迟函数</p><p>动态显示的延迟函数不能像之前的一样，而应该在延迟函数的<code>while</code>函数中一直进行动态显示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_Dynamic</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(t--)&#123;</span><br><span class="line"> SMG_Dynamic();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">SMG_Static();</span><br><span class="line">SMG_Dynamic();</span><br><span class="line">Delay_Dynamic(<span class="number">100</span>);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​这样我们就可以随意控制8个数码管显示任何数字以及实现我们想要完成的变化了</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><h3 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h3><p>单个独立按键内部结构如下图所示，按下按键时输出低电平（接地），松开输出高电平（接VCC电源了）</p><img src="/image/${fiilename}/image-20240226182037139.png" alt="image-20240226182037139" style="zoom:50%;" /><p>独立按键共有四个：S7, S6, S5, S4，电路图如下所示，其中最左侧一列四个为独立按键</p><p><img src="/image/$%7Bfiilename%7D/image-20240226175148420.png" alt="image-20240226175148420"></p><p>将<code>J5</code>跳帽连接2,3引脚切换至独立按键模式</p><p>4个独立按键电路非常简单，P3^0-3依次连接独立按键的S7, S6, S5, S4</p><p>在代码中只需将S与P3相对应：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit S7 = P3^<span class="number">0</span>;</span><br><span class="line">sbit S6 = P3^<span class="number">1</span>;</span><br><span class="line">sbit S5 = P3^<span class="number">2</span>;</span><br><span class="line">sbit S4 = P3^<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在按键操作的代码中，我们需要做去抖动处理，从而识别有效按键，比如下面代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(S7 == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line">L1 = <span class="number">0</span>；</span><br><span class="line">            <span class="keyword">while</span>(S7 == <span class="number">0</span>);</span><br><span class="line">            L1 = <span class="number">1</span>；</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过使用<code>Delay(100)</code>实现了去抖动。</p><p>S7按下则L1亮，松开则灭</p><p>同时，我们用独立按键控制灯泡明灭会遇到两种情况：第一种情况就是上述的按下灯亮，松开灯灭；第二种就是按下灯亮，松开灯不灭，再次按下该按键灯才灭。第二种情况可以如下实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sta表示当前状态</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (S7 == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (sta == <span class="number">0</span>)&#123;</span><br><span class="line">sta = <span class="number">1</span>;</span><br><span class="line">L1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sta == <span class="number">1</span>)&#123;</span><br><span class="line">sta = <span class="number">0</span>;</span><br><span class="line"> L1 = <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(S7 == <span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码<code>if</code>判断的最后，我们使用了<code>while(S7 == 0);</code>从而避免按S7的时候程序反复进入该<code>if</code>判断中，这样可以使得按一下按键只进入一次<code>if</code>判断语句。</p><h3 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h3><h4 id="电路部分-2"><a href="#电路部分-2" class="headerlink" title="电路部分"></a>电路部分</h4><p>将<code>J5</code>跳帽连接1,2引脚切换至矩阵键盘模式</p><img src="/image/${fiilename}/image-20240226185144689.png" alt="image-20240226185144689" style="zoom:50%;" /><p>与独立按键不同，矩阵键盘左端不接地，而是连接I&#x2F;O输入，当左端输入为0且右端输出为0时，说明该按键被按下</p><p>所以，我们需要扫描按键，即逐行接低电平，检测每列输出，输出低电平则可以锁定行列坐标</p><p><img src="/image/$%7Bfiilename%7D/image-20240226175148420.png" alt="image-20240226175148420"></p><h4 id="代码部分-2"><a href="#代码部分-2" class="headerlink" title="代码部分"></a>代码部分</h4><p>首先，我们将行用R1-4表示，列用C1-4表示（由于我们引用的<code>reg52.h</code>头文件中没有P4端口，所以我们需要提前定义一下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义P4口， 电路图中P36为P42，P37为P44</span></span><br><span class="line">sfr P4 = <span class="number">0xc0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//R代表矩阵行，C代表矩阵列</span></span><br><span class="line">sbit R1 = P3^<span class="number">0</span>;</span><br><span class="line">sbit R2 = P3^<span class="number">1</span>;</span><br><span class="line">sbit R3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit R4 = P3^<span class="number">3</span>;</span><br><span class="line">sbit C4 = P3^<span class="number">4</span>;</span><br><span class="line">sbit C3 = P3^<span class="number">5</span>;</span><br><span class="line">sbit C2 = P4^<span class="number">2</span>;</span><br><span class="line">sbit C1 = P4^<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>然后，我们开始逐行扫描矩阵键盘</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeyMul</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//第一行</span></span><br><span class="line">R1 = <span class="number">0</span>;</span><br><span class="line">R2 = R3 = R4 = <span class="number">1</span>; </span><br><span class="line">C1 = C2 = C3 = C4 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (C1 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C1 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C2 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C2 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C3 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C3 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (C4 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (C4 == <span class="number">0</span>);</span><br><span class="line">key_num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二、三、四行同理，复制粘贴略加改动即可</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们便可以确定哪个按键被按下，同时在对应的if判断语句中写下我们要进行的操作即可实现矩阵键盘相关的控制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
